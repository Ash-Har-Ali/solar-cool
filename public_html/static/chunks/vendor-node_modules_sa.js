"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendor-node_modules_sa"],{

/***/ "./node_modules/scheduler/cjs/scheduler.development.js":
/*!*************************************************************!*\
  !*** ./node_modules/scheduler/cjs/scheduler.development.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n\n          'use strict';\n\n/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n}\n          var enableSchedulerDebugging = false;\nvar enableProfiling = false;\nvar frameYieldMs = 5;\n\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  siftUp(heap, node, index);\n}\nfunction peek(heap) {\n  return heap.length === 0 ? null : heap[0];\n}\nfunction pop(heap) {\n  if (heap.length === 0) {\n    return null;\n  }\n\n  var first = heap[0];\n  var last = heap.pop();\n\n  if (last !== first) {\n    heap[0] = last;\n    siftDown(heap, last, 0);\n  }\n\n  return first;\n}\n\nfunction siftUp(heap, node, i) {\n  var index = i;\n\n  while (index > 0) {\n    var parentIndex = index - 1 >>> 1;\n    var parent = heap[parentIndex];\n\n    if (compare(parent, node) > 0) {\n      // The parent is larger. Swap positions.\n      heap[parentIndex] = node;\n      heap[index] = parent;\n      index = parentIndex;\n    } else {\n      // The parent is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction siftDown(heap, node, i) {\n  var index = i;\n  var length = heap.length;\n  var halfLength = length >>> 1;\n\n  while (index < halfLength) {\n    var leftIndex = (index + 1) * 2 - 1;\n    var left = heap[leftIndex];\n    var rightIndex = leftIndex + 1;\n    var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n\n    if (compare(left, node) < 0) {\n      if (rightIndex < length && compare(right, left) < 0) {\n        heap[index] = right;\n        heap[rightIndex] = node;\n        index = rightIndex;\n      } else {\n        heap[index] = left;\n        heap[leftIndex] = node;\n        index = leftIndex;\n      }\n    } else if (rightIndex < length && compare(right, node) < 0) {\n      heap[index] = right;\n      heap[rightIndex] = node;\n      index = rightIndex;\n    } else {\n      // Neither child is smaller. Exit.\n      return;\n    }\n  }\n}\n\nfunction compare(a, b) {\n  // Compare sort index first, then task id.\n  var diff = a.sortIndex - b.sortIndex;\n  return diff !== 0 ? diff : a.id - b.id;\n}\n\n// TODO: Use symbols?\nvar ImmediatePriority = 1;\nvar UserBlockingPriority = 2;\nvar NormalPriority = 3;\nvar LowPriority = 4;\nvar IdlePriority = 5;\n\nfunction markTaskErrored(task, ms) {\n}\n\n/* eslint-disable no-var */\n\nvar hasPerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nif (hasPerformanceNow) {\n  var localPerformance = performance;\n\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date;\n  var initialTime = localDate.now();\n\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n} // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n// Math.pow(2, 30) - 1\n// 0b111111111111111111111111111111\n\n\nvar maxSigned31BitInt = 1073741823; // Times out immediately\n\nvar IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n\nvar USER_BLOCKING_PRIORITY_TIMEOUT = 250;\nvar NORMAL_PRIORITY_TIMEOUT = 5000;\nvar LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n\nvar IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n\nvar taskQueue = [];\nvar timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n\nvar taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\nvar currentTask = null;\nvar currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n\nvar isPerformingWork = false;\nvar isHostCallbackScheduled = false;\nvar isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : null;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : null;\nvar localSetImmediate = typeof setImmediate !== 'undefined' ? setImmediate : null; // IE and Node.js + jsdom\n\nvar isInputPending = typeof navigator !== 'undefined' && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n\nfunction advanceTimers(currentTime) {\n  // Check for tasks that are no longer delayed and add them to the queue.\n  var timer = peek(timerQueue);\n\n  while (timer !== null) {\n    if (timer.callback === null) {\n      // Timer was cancelled.\n      pop(timerQueue);\n    } else if (timer.startTime <= currentTime) {\n      // Timer fired. Transfer to the task queue.\n      pop(timerQueue);\n      timer.sortIndex = timer.expirationTime;\n      push(taskQueue, timer);\n    } else {\n      // Remaining timers are pending.\n      return;\n    }\n\n    timer = peek(timerQueue);\n  }\n}\n\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = false;\n  advanceTimers(currentTime);\n\n  if (!isHostCallbackScheduled) {\n    if (peek(taskQueue) !== null) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    } else {\n      var firstTimer = peek(timerQueue);\n\n      if (firstTimer !== null) {\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n      }\n    }\n  }\n}\n\nfunction flushWork(hasTimeRemaining, initialTime) {\n\n\n  isHostCallbackScheduled = false;\n\n  if (isHostTimeoutScheduled) {\n    // We scheduled a timeout but it's no longer needed. Cancel it.\n    isHostTimeoutScheduled = false;\n    cancelHostTimeout();\n  }\n\n  isPerformingWork = true;\n  var previousPriorityLevel = currentPriorityLevel;\n\n  try {\n    if (enableProfiling) {\n      try {\n        return workLoop(hasTimeRemaining, initialTime);\n      } catch (error) {\n        if (currentTask !== null) {\n          var currentTime = exports.unstable_now();\n          markTaskErrored(currentTask, currentTime);\n          currentTask.isQueued = false;\n        }\n\n        throw error;\n      }\n    } else {\n      // No catch in prod code path.\n      return workLoop(hasTimeRemaining, initialTime);\n    }\n  } finally {\n    currentTask = null;\n    currentPriorityLevel = previousPriorityLevel;\n    isPerformingWork = false;\n  }\n}\n\nfunction workLoop(hasTimeRemaining, initialTime) {\n  var currentTime = initialTime;\n  advanceTimers(currentTime);\n  currentTask = peek(taskQueue);\n\n  while (currentTask !== null && !(enableSchedulerDebugging )) {\n    if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n      // This currentTask hasn't expired, and we've reached the deadline.\n      break;\n    }\n\n    var callback = currentTask.callback;\n\n    if (typeof callback === 'function') {\n      currentTask.callback = null;\n      currentPriorityLevel = currentTask.priorityLevel;\n      var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n\n      var continuationCallback = callback(didUserCallbackTimeout);\n      currentTime = exports.unstable_now();\n\n      if (typeof continuationCallback === 'function') {\n        currentTask.callback = continuationCallback;\n      } else {\n\n        if (currentTask === peek(taskQueue)) {\n          pop(taskQueue);\n        }\n      }\n\n      advanceTimers(currentTime);\n    } else {\n      pop(taskQueue);\n    }\n\n    currentTask = peek(taskQueue);\n  } // Return whether there's additional work\n\n\n  if (currentTask !== null) {\n    return true;\n  } else {\n    var firstTimer = peek(timerQueue);\n\n    if (firstTimer !== null) {\n      requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n\n    return false;\n  }\n}\n\nfunction unstable_runWithPriority(priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n    case LowPriority:\n    case IdlePriority:\n      break;\n\n    default:\n      priorityLevel = NormalPriority;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_next(eventHandler) {\n  var priorityLevel;\n\n  switch (currentPriorityLevel) {\n    case ImmediatePriority:\n    case UserBlockingPriority:\n    case NormalPriority:\n      // Shift down to normal priority\n      priorityLevel = NormalPriority;\n      break;\n\n    default:\n      // Anything lower than normal priority should remain at the current level.\n      priorityLevel = currentPriorityLevel;\n      break;\n  }\n\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n}\n\nfunction unstable_wrapCallback(callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    // This is a fork of runWithPriority, inlined for performance.\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n}\n\nfunction unstable_scheduleCallback(priorityLevel, callback, options) {\n  var currentTime = exports.unstable_now();\n  var startTime;\n\n  if (typeof options === 'object' && options !== null) {\n    var delay = options.delay;\n\n    if (typeof delay === 'number' && delay > 0) {\n      startTime = currentTime + delay;\n    } else {\n      startTime = currentTime;\n    }\n  } else {\n    startTime = currentTime;\n  }\n\n  var timeout;\n\n  switch (priorityLevel) {\n    case ImmediatePriority:\n      timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n      break;\n\n    case UserBlockingPriority:\n      timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n      break;\n\n    case IdlePriority:\n      timeout = IDLE_PRIORITY_TIMEOUT;\n      break;\n\n    case LowPriority:\n      timeout = LOW_PRIORITY_TIMEOUT;\n      break;\n\n    case NormalPriority:\n    default:\n      timeout = NORMAL_PRIORITY_TIMEOUT;\n      break;\n  }\n\n  var expirationTime = startTime + timeout;\n  var newTask = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: startTime,\n    expirationTime: expirationTime,\n    sortIndex: -1\n  };\n\n  if (startTime > currentTime) {\n    // This is a delayed task.\n    newTask.sortIndex = startTime;\n    push(timerQueue, newTask);\n\n    if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n      // All tasks are delayed, and this is the task with the earliest delay.\n      if (isHostTimeoutScheduled) {\n        // Cancel an existing timeout.\n        cancelHostTimeout();\n      } else {\n        isHostTimeoutScheduled = true;\n      } // Schedule a timeout.\n\n\n      requestHostTimeout(handleTimeout, startTime - currentTime);\n    }\n  } else {\n    newTask.sortIndex = expirationTime;\n    push(taskQueue, newTask);\n    // wait until the next time we yield.\n\n\n    if (!isHostCallbackScheduled && !isPerformingWork) {\n      isHostCallbackScheduled = true;\n      requestHostCallback(flushWork);\n    }\n  }\n\n  return newTask;\n}\n\nfunction unstable_pauseExecution() {\n}\n\nfunction unstable_continueExecution() {\n\n  if (!isHostCallbackScheduled && !isPerformingWork) {\n    isHostCallbackScheduled = true;\n    requestHostCallback(flushWork);\n  }\n}\n\nfunction unstable_getFirstCallbackNode() {\n  return peek(taskQueue);\n}\n\nfunction unstable_cancelCallback(task) {\n  // remove from the queue because you can't remove arbitrary nodes from an\n  // array based heap, only the first one.)\n\n\n  task.callback = null;\n}\n\nfunction unstable_getCurrentPriorityLevel() {\n  return currentPriorityLevel;\n}\n\nvar isMessageLoopRunning = false;\nvar scheduledHostCallback = null;\nvar taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n// thread, like user events. By default, it yields multiple times per frame.\n// It does not attempt to align with frame boundaries, since most tasks don't\n// need to be frame aligned; for those that do, use requestAnimationFrame.\n\nvar frameInterval = frameYieldMs;\nvar startTime = -1;\n\nfunction shouldYieldToHost() {\n  var timeElapsed = exports.unstable_now() - startTime;\n\n  if (timeElapsed < frameInterval) {\n    // The main thread has only been blocked for a really short amount of time;\n    // smaller than a single frame. Don't yield yet.\n    return false;\n  } // The main thread has been blocked for a non-negligible amount of time. We\n\n\n  return true;\n}\n\nfunction requestPaint() {\n\n}\n\nfunction forceFrameRate(fps) {\n  if (fps < 0 || fps > 125) {\n    // Using console['error'] to evade Babel and ESLint\n    console['error']('forceFrameRate takes a positive int between 0 and 125, ' + 'forcing frame rates higher than 125 fps is not supported');\n    return;\n  }\n\n  if (fps > 0) {\n    frameInterval = Math.floor(1000 / fps);\n  } else {\n    // reset the framerate\n    frameInterval = frameYieldMs;\n  }\n}\n\nvar performWorkUntilDeadline = function () {\n  if (scheduledHostCallback !== null) {\n    var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n    // has been blocked.\n\n    startTime = currentTime;\n    var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n    // error can be observed.\n    //\n    // Intentionally not using a try-catch, since that makes some debugging\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\n\n    var hasMoreWork = true;\n\n    try {\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n    } finally {\n      if (hasMoreWork) {\n        // If there's more work, schedule the next message event at the end\n        // of the preceding one.\n        schedulePerformWorkUntilDeadline();\n      } else {\n        isMessageLoopRunning = false;\n        scheduledHostCallback = null;\n      }\n    }\n  } else {\n    isMessageLoopRunning = false;\n  } // Yielding to the browser will give it a chance to paint, so we can\n};\n\nvar schedulePerformWorkUntilDeadline;\n\nif (typeof localSetImmediate === 'function') {\n  // Node.js and old IE.\n  // There's a few reasons for why we prefer setImmediate.\n  //\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n  // (Even though this is a DOM fork of the Scheduler, you could get here\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n  // https://github.com/facebook/react/issues/20756\n  //\n  // But also, it runs earlier which is the semantic we want.\n  // If other browsers ever implement it, it's better to use it.\n  // Although both of these would be inferior to native scheduling.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\n} else if (typeof MessageChannel !== 'undefined') {\n  // DOM and Worker environments.\n  // We prefer MessageChannel because of the 4ms setTimeout clamping.\n  var channel = new MessageChannel();\n  var port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else {\n  // We should only fallback here in non-browser environments.\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\n}\n\nfunction requestHostCallback(callback) {\n  scheduledHostCallback = callback;\n\n  if (!isMessageLoopRunning) {\n    isMessageLoopRunning = true;\n    schedulePerformWorkUntilDeadline();\n  }\n}\n\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\n\nfunction cancelHostTimeout() {\n  localClearTimeout(taskTimeoutID);\n  taskTimeoutID = -1;\n}\n\nvar unstable_requestPaint = requestPaint;\nvar unstable_Profiling =  null;\n\nexports.unstable_IdlePriority = IdlePriority;\nexports.unstable_ImmediatePriority = ImmediatePriority;\nexports.unstable_LowPriority = LowPriority;\nexports.unstable_NormalPriority = NormalPriority;\nexports.unstable_Profiling = unstable_Profiling;\nexports.unstable_UserBlockingPriority = UserBlockingPriority;\nexports.unstable_cancelCallback = unstable_cancelCallback;\nexports.unstable_continueExecution = unstable_continueExecution;\nexports.unstable_forceFrameRate = forceFrameRate;\nexports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\nexports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\nexports.unstable_next = unstable_next;\nexports.unstable_pauseExecution = unstable_pauseExecution;\nexports.unstable_requestPaint = unstable_requestPaint;\nexports.unstable_runWithPriority = unstable_runWithPriority;\nexports.unstable_scheduleCallback = unstable_scheduleCallback;\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = unstable_wrapCallback;\n          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\nif (\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n    'function'\n) {\n  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n}\n        \n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRSxvQkFBb0I7QUFDdEI7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLEVBQUUsb0JBQW9CO0FBQ3RCO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7O0FBR0Esb0NBQW9DOztBQUVwQyxxQ0FBcUM7O0FBRXJDO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDLCtDQUErQzs7QUFFL0M7QUFDQSxxQkFBcUI7O0FBRXJCLHVCQUF1QjtBQUN2QjtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBLG9DQUFvQzs7QUFFcEM7QUFDQTtBQUNBLG1GQUFtRjs7QUFFbkY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QixrQ0FBa0M7QUFDbEMsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiwwQkFBMEI7QUFDMUIscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQixrQ0FBa0M7QUFDbEMsK0JBQStCO0FBQy9CLHdDQUF3QztBQUN4QyxxQ0FBcUM7QUFDckMscUJBQXFCO0FBQ3JCLCtCQUErQjtBQUMvQiw2QkFBNkI7QUFDN0IsZ0NBQWdDO0FBQ2hDLGlDQUFpQztBQUNqQyw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/YmNkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG52YXIgZW5hYmxlUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZnJhbWVZaWVsZE1zID0gNTtcblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG4gIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGhhbGZMZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzOyAvLyBUaW1lcyBvdXQgaW1tZWRpYXRlbHlcblxudmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbnZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG52YXIgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG52YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbnZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxudmFyIGN1cnJlbnRUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbnZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG52YXIgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbnZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbnZhciBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG5cbiAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoc3RhcnRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgIHB1c2godGltZXJRdWV1ZSwgbmV3VGFzayk7XG5cbiAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICBwdXNoKHRhc2tRdWV1ZSwgbmV3VGFzayk7XG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cbiAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rhc2s7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbigpIHtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG52YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbnZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbnZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xudmFyIHN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBvbmx5IGJlZW4gYmxvY2tlZCBmb3IgYSByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWU7XG4gICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBtYWluIHRocmVhZCBoYXMgYmVlbiBibG9ja2VkIGZvciBhIG5vbi1uZWdsaWdpYmxlIGFtb3VudCBvZiB0aW1lLiBXZVxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHtcblxufVxuXG5mdW5jdGlvbiBmb3JjZUZyYW1lUmF0ZShmcHMpIHtcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZnBzID4gMCkge1xuICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICB9XG59XG5cbnZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIGhhcyBiZWVuIGJsb2NrZWQuXG5cbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7IC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgLy9cbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgIC8vIHRlY2huaXF1ZXMgaGFyZGVyLiBJbnN0ZWFkLCBpZiBgc2NoZWR1bGVkSG9zdENhbGxiYWNrYCBlcnJvcnMsIHRoZW5cbiAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgdmFyIGhhc01vcmVXb3JrID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxufTtcblxudmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5pZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSBhbmQgV29ya2VyIGVudmlyb25tZW50cy5cbiAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIG1zKTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG5cbnZhciB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSByZXF1ZXN0UGFpbnQ7XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/scheduler/cjs/scheduler.development.js\n"));

/***/ }),

/***/ "./node_modules/scheduler/index.js":
/*!*****************************************!*\
  !*** ./node_modules/scheduler/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"./node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxtSUFBMEQ7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NjaGVkdWxlci9pbmRleC5qcz9jN2NjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvc2NoZWR1bGVyLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/scheduler/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/image-url/lib/browser/image-url.umd.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sanity/image-url/lib/browser/image-url.umd.js ***!
  \*********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n(function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    function _extends() {\n        _extends = Object.assign || function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source){\n                    if (Object.prototype.hasOwnProperty.call(source, key)) {\n                        target[key] = source[key];\n                    }\n                }\n            }\n            return target;\n        };\n        return _extends.apply(this, arguments);\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n        return arr2;\n    }\n    function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n        var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n        if (it) return (it = it.call(o)).next.bind(it);\n        if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n            if (it) o = it;\n            var i = 0;\n            return function() {\n                if (i >= o.length) return {\n                    done: true\n                };\n                return {\n                    done: false,\n                    value: o[i++]\n                };\n            };\n        }\n        throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var example = \"image-Tb9Ew8CXIwaY6R1kjMvI0uRR-2000x3000-jpg\";\n    function parseAssetId(ref) {\n        var _ref$split = ref.split(\"-\"), id = _ref$split[1], dimensionString = _ref$split[2], format = _ref$split[3];\n        if (!id || !dimensionString || !format) {\n            throw new Error(\"Malformed asset _ref '\" + ref + \"'. Expected an id like \\\"\" + example + '\".');\n        }\n        var _dimensionString$spli = dimensionString.split(\"x\"), imgWidthStr = _dimensionString$spli[0], imgHeightStr = _dimensionString$spli[1];\n        var width = +imgWidthStr;\n        var height = +imgHeightStr;\n        var isValidAssetId = isFinite(width) && isFinite(height);\n        if (!isValidAssetId) {\n            throw new Error(\"Malformed asset _ref '\" + ref + \"'. Expected an id like \\\"\" + example + '\".');\n        }\n        return {\n            id: id,\n            width: width,\n            height: height,\n            format: format\n        };\n    }\n    var isRef = function isRef(src) {\n        var source = src;\n        return source ? typeof source._ref === \"string\" : false;\n    };\n    var isAsset = function isAsset(src) {\n        var source = src;\n        return source ? typeof source._id === \"string\" : false;\n    };\n    var isAssetStub = function isAssetStub(src) {\n        var source = src;\n        return source && source.asset ? typeof source.asset.url === \"string\" : false;\n    }; // Convert an asset-id, asset or image to an image record suitable for processing\n    // eslint-disable-next-line complexity\n    function parseSource(source) {\n        if (!source) {\n            return null;\n        }\n        var image;\n        if (typeof source === \"string\" && isUrl(source)) {\n            // Someone passed an existing image url?\n            image = {\n                asset: {\n                    _ref: urlToId(source)\n                }\n            };\n        } else if (typeof source === \"string\") {\n            // Just an asset id\n            image = {\n                asset: {\n                    _ref: source\n                }\n            };\n        } else if (isRef(source)) {\n            // We just got passed an asset directly\n            image = {\n                asset: source\n            };\n        } else if (isAsset(source)) {\n            // If we were passed an image asset document\n            image = {\n                asset: {\n                    _ref: source._id || \"\"\n                }\n            };\n        } else if (isAssetStub(source)) {\n            // If we were passed a partial asset (`url`, but no `_id`)\n            image = {\n                asset: {\n                    _ref: urlToId(source.asset.url)\n                }\n            };\n        } else if (typeof source.asset === \"object\") {\n            // Probably an actual image with materialized asset\n            image = _extends({}, source);\n        } else {\n            // We got something that does not look like an image, or it is an image\n            // that currently isn't sporting an asset.\n            return null;\n        }\n        var img = source;\n        if (img.crop) {\n            image.crop = img.crop;\n        }\n        if (img.hotspot) {\n            image.hotspot = img.hotspot;\n        }\n        return applyDefaults(image);\n    }\n    function isUrl(url) {\n        return /^https?:\\/\\//.test(\"\" + url);\n    }\n    function urlToId(url) {\n        var parts = url.split(\"/\").slice(-1);\n        return (\"image-\" + parts[0]).replace(/\\.([a-z]+)$/, \"-$1\");\n    } // Mock crop and hotspot if image lacks it\n    function applyDefaults(image) {\n        if (image.crop && image.hotspot) {\n            return image;\n        } // We need to pad in default values for crop or hotspot\n        var result = _extends({}, image);\n        if (!result.crop) {\n            result.crop = {\n                left: 0,\n                top: 0,\n                bottom: 0,\n                right: 0\n            };\n        }\n        if (!result.hotspot) {\n            result.hotspot = {\n                x: 0.5,\n                y: 0.5,\n                height: 1.0,\n                width: 1.0\n            };\n        }\n        return result;\n    }\n    var SPEC_NAME_TO_URL_NAME_MAPPINGS = [\n        [\n            \"width\",\n            \"w\"\n        ],\n        [\n            \"height\",\n            \"h\"\n        ],\n        [\n            \"format\",\n            \"fm\"\n        ],\n        [\n            \"download\",\n            \"dl\"\n        ],\n        [\n            \"blur\",\n            \"blur\"\n        ],\n        [\n            \"sharpen\",\n            \"sharp\"\n        ],\n        [\n            \"invert\",\n            \"invert\"\n        ],\n        [\n            \"orientation\",\n            \"or\"\n        ],\n        [\n            \"minHeight\",\n            \"min-h\"\n        ],\n        [\n            \"maxHeight\",\n            \"max-h\"\n        ],\n        [\n            \"minWidth\",\n            \"min-w\"\n        ],\n        [\n            \"maxWidth\",\n            \"max-w\"\n        ],\n        [\n            \"quality\",\n            \"q\"\n        ],\n        [\n            \"fit\",\n            \"fit\"\n        ],\n        [\n            \"crop\",\n            \"crop\"\n        ],\n        [\n            \"saturation\",\n            \"sat\"\n        ],\n        [\n            \"auto\",\n            \"auto\"\n        ],\n        [\n            \"dpr\",\n            \"dpr\"\n        ],\n        [\n            \"pad\",\n            \"pad\"\n        ]\n    ];\n    function urlForImage(options) {\n        var spec = _extends({}, options || {});\n        var source = spec.source;\n        delete spec.source;\n        var image = parseSource(source);\n        if (!image) {\n            throw new Error(\"Unable to resolve image URL from source (\" + JSON.stringify(source) + \")\");\n        }\n        var id = image.asset._ref || image.asset._id || \"\";\n        var asset = parseAssetId(id); // Compute crop rect in terms of pixel coordinates in the raw source image\n        var cropLeft = Math.round(image.crop.left * asset.width);\n        var cropTop = Math.round(image.crop.top * asset.height);\n        var crop = {\n            left: cropLeft,\n            top: cropTop,\n            width: Math.round(asset.width - image.crop.right * asset.width - cropLeft),\n            height: Math.round(asset.height - image.crop.bottom * asset.height - cropTop)\n        }; // Compute hot spot rect in terms of pixel coordinates\n        var hotSpotVerticalRadius = image.hotspot.height * asset.height / 2;\n        var hotSpotHorizontalRadius = image.hotspot.width * asset.width / 2;\n        var hotSpotCenterX = image.hotspot.x * asset.width;\n        var hotSpotCenterY = image.hotspot.y * asset.height;\n        var hotspot = {\n            left: hotSpotCenterX - hotSpotHorizontalRadius,\n            top: hotSpotCenterY - hotSpotVerticalRadius,\n            right: hotSpotCenterX + hotSpotHorizontalRadius,\n            bottom: hotSpotCenterY + hotSpotVerticalRadius\n        }; // If irrelevant, or if we are requested to: don't perform crop/fit based on\n        // the crop/hotspot.\n        if (!(spec.rect || spec.focalPoint || spec.ignoreImageParams || spec.crop)) {\n            spec = _extends({}, spec, fit({\n                crop: crop,\n                hotspot: hotspot\n            }, spec));\n        }\n        return specToImageUrl(_extends({}, spec, {\n            asset: asset\n        }));\n    } // eslint-disable-next-line complexity\n    function specToImageUrl(spec) {\n        var cdnUrl = (spec.baseUrl || \"https://cdn.sanity.io\").replace(/\\/+$/, \"\");\n        var filename = spec.asset.id + \"-\" + spec.asset.width + \"x\" + spec.asset.height + \".\" + spec.asset.format;\n        var baseUrl = cdnUrl + \"/images/\" + spec.projectId + \"/\" + spec.dataset + \"/\" + filename;\n        var params = [];\n        if (spec.rect) {\n            // Only bother url with a crop if it actually crops anything\n            var _spec$rect = spec.rect, left = _spec$rect.left, top = _spec$rect.top, width = _spec$rect.width, height = _spec$rect.height;\n            var isEffectiveCrop = left !== 0 || top !== 0 || height !== spec.asset.height || width !== spec.asset.width;\n            if (isEffectiveCrop) {\n                params.push(\"rect=\" + left + \",\" + top + \",\" + width + \",\" + height);\n            }\n        }\n        if (spec.bg) {\n            params.push(\"bg=\" + spec.bg);\n        }\n        if (spec.focalPoint) {\n            params.push(\"fp-x=\" + spec.focalPoint.x);\n            params.push(\"fp-y=\" + spec.focalPoint.y);\n        }\n        var flip = [\n            spec.flipHorizontal && \"h\",\n            spec.flipVertical && \"v\"\n        ].filter(Boolean).join(\"\");\n        if (flip) {\n            params.push(\"flip=\" + flip);\n        } // Map from spec name to url param name, and allow using the actual param name as an alternative\n        SPEC_NAME_TO_URL_NAME_MAPPINGS.forEach(function(mapping) {\n            var specName = mapping[0], param = mapping[1];\n            if (typeof spec[specName] !== \"undefined\") {\n                params.push(param + \"=\" + encodeURIComponent(spec[specName]));\n            } else if (typeof spec[param] !== \"undefined\") {\n                params.push(param + \"=\" + encodeURIComponent(spec[param]));\n            }\n        });\n        if (params.length === 0) {\n            return baseUrl;\n        }\n        return baseUrl + \"?\" + params.join(\"&\");\n    }\n    function fit(source, spec) {\n        var cropRect;\n        var imgWidth = spec.width;\n        var imgHeight = spec.height; // If we are not constraining the aspect ratio, we'll just use the whole crop\n        if (!(imgWidth && imgHeight)) {\n            return {\n                width: imgWidth,\n                height: imgHeight,\n                rect: source.crop\n            };\n        }\n        var crop = source.crop;\n        var hotspot = source.hotspot; // If we are here, that means aspect ratio is locked and fitting will be a bit harder\n        var desiredAspectRatio = imgWidth / imgHeight;\n        var cropAspectRatio = crop.width / crop.height;\n        if (cropAspectRatio > desiredAspectRatio) {\n            // The crop is wider than the desired aspect ratio. That means we are cutting from the sides\n            var height = Math.round(crop.height);\n            var width = Math.round(height * desiredAspectRatio);\n            var top = Math.max(0, Math.round(crop.top)); // Center output horizontally over hotspot\n            var hotspotXCenter = Math.round((hotspot.right - hotspot.left) / 2 + hotspot.left);\n            var left = Math.max(0, Math.round(hotspotXCenter - width / 2)); // Keep output within crop\n            if (left < crop.left) {\n                left = crop.left;\n            } else if (left + width > crop.left + crop.width) {\n                left = crop.left + crop.width - width;\n            }\n            cropRect = {\n                left: left,\n                top: top,\n                width: width,\n                height: height\n            };\n        } else {\n            // The crop is taller than the desired ratio, we are cutting from top and bottom\n            var _width = crop.width;\n            var _height = Math.round(_width / desiredAspectRatio);\n            var _left = Math.max(0, Math.round(crop.left)); // Center output vertically over hotspot\n            var hotspotYCenter = Math.round((hotspot.bottom - hotspot.top) / 2 + hotspot.top);\n            var _top = Math.max(0, Math.round(hotspotYCenter - _height / 2)); // Keep output rect within crop\n            if (_top < crop.top) {\n                _top = crop.top;\n            } else if (_top + _height > crop.top + crop.height) {\n                _top = crop.top + crop.height - _height;\n            }\n            cropRect = {\n                left: _left,\n                top: _top,\n                width: _width,\n                height: _height\n            };\n        }\n        return {\n            width: imgWidth,\n            height: imgHeight,\n            rect: cropRect\n        };\n    } // For backwards-compatibility\n    var validFits = [\n        \"clip\",\n        \"crop\",\n        \"fill\",\n        \"fillmax\",\n        \"max\",\n        \"scale\",\n        \"min\"\n    ];\n    var validCrops = [\n        \"top\",\n        \"bottom\",\n        \"left\",\n        \"right\",\n        \"center\",\n        \"focalpoint\",\n        \"entropy\"\n    ];\n    var validAutoModes = [\n        \"format\"\n    ];\n    function isSanityModernClientLike(client) {\n        return client && \"config\" in client ? typeof client.config === \"function\" : false;\n    }\n    function isSanityClientLike(client) {\n        return client && \"clientConfig\" in client ? typeof client.clientConfig === \"object\" : false;\n    }\n    function rewriteSpecName(key) {\n        var specs = SPEC_NAME_TO_URL_NAME_MAPPINGS;\n        for(var _iterator = _createForOfIteratorHelperLoose(specs), _step; !(_step = _iterator()).done;){\n            var entry = _step.value;\n            var specName = entry[0], param = entry[1];\n            if (key === specName || key === param) {\n                return specName;\n            }\n        }\n        return key;\n    }\n    function urlBuilder(options) {\n        // Did we get a modernish client?\n        if (isSanityModernClientLike(options)) {\n            // Inherit config from client\n            var _options$config = options.config(), apiUrl = _options$config.apiHost, projectId = _options$config.projectId, dataset = _options$config.dataset;\n            var apiHost = apiUrl || \"https://api.sanity.io\";\n            return new ImageUrlBuilder(null, {\n                baseUrl: apiHost.replace(/^https:\\/\\/api\\./, \"https://cdn.\"),\n                projectId: projectId,\n                dataset: dataset\n            });\n        } // Did we get a SanityClient?\n        var client = options;\n        if (isSanityClientLike(client)) {\n            // Inherit config from client\n            var _client$clientConfig = client.clientConfig, _apiUrl = _client$clientConfig.apiHost, _projectId = _client$clientConfig.projectId, _dataset = _client$clientConfig.dataset;\n            var _apiHost = _apiUrl || \"https://api.sanity.io\";\n            return new ImageUrlBuilder(null, {\n                baseUrl: _apiHost.replace(/^https:\\/\\/api\\./, \"https://cdn.\"),\n                projectId: _projectId,\n                dataset: _dataset\n            });\n        } // Or just accept the options as given\n        return new ImageUrlBuilder(null, options);\n    }\n    var ImageUrlBuilder = /*#__PURE__*/ function() {\n        function ImageUrlBuilder(parent, options) {\n            this.options = void 0;\n            this.options = parent ? _extends({}, parent.options || {}, options || {}) // Merge parent options\n             : _extends({}, options || {}); // Copy options\n        }\n        var _proto = ImageUrlBuilder.prototype;\n        _proto.withOptions = function withOptions(options) {\n            var baseUrl = options.baseUrl || this.options.baseUrl;\n            var newOptions = {\n                baseUrl: baseUrl\n            };\n            for(var key in options){\n                if (options.hasOwnProperty(key)) {\n                    var specKey = rewriteSpecName(key);\n                    newOptions[specKey] = options[key];\n                }\n            }\n            return new ImageUrlBuilder(this, _extends({\n                baseUrl: baseUrl\n            }, newOptions));\n        } // The image to be represented. Accepts a Sanity 'image'-document, 'asset'-document or\n        ;\n        _proto.image = function image(source) {\n            return this.withOptions({\n                source: source\n            });\n        } // Specify the dataset\n        ;\n        _proto.dataset = function dataset(_dataset2) {\n            return this.withOptions({\n                dataset: _dataset2\n            });\n        } // Specify the projectId\n        ;\n        _proto.projectId = function projectId(_projectId2) {\n            return this.withOptions({\n                projectId: _projectId2\n            });\n        } // Specify background color\n        ;\n        _proto.bg = function bg(_bg) {\n            return this.withOptions({\n                bg: _bg\n            });\n        } // Set DPR scaling factor\n        ;\n        _proto.dpr = function dpr(_dpr) {\n            // A DPR of 1 is the default - so only include it if we have a different value\n            return this.withOptions(_dpr && _dpr !== 1 ? {\n                dpr: _dpr\n            } : {});\n        } // Specify the width of the image in pixels\n        ;\n        _proto.width = function width(_width) {\n            return this.withOptions({\n                width: _width\n            });\n        } // Specify the height of the image in pixels\n        ;\n        _proto.height = function height(_height) {\n            return this.withOptions({\n                height: _height\n            });\n        } // Specify focal point in fraction of image dimensions. Each component 0.0-1.0\n        ;\n        _proto.focalPoint = function focalPoint(x, y) {\n            return this.withOptions({\n                focalPoint: {\n                    x: x,\n                    y: y\n                }\n            });\n        };\n        _proto.maxWidth = function maxWidth(_maxWidth) {\n            return this.withOptions({\n                maxWidth: _maxWidth\n            });\n        };\n        _proto.minWidth = function minWidth(_minWidth) {\n            return this.withOptions({\n                minWidth: _minWidth\n            });\n        };\n        _proto.maxHeight = function maxHeight(_maxHeight) {\n            return this.withOptions({\n                maxHeight: _maxHeight\n            });\n        };\n        _proto.minHeight = function minHeight(_minHeight) {\n            return this.withOptions({\n                minHeight: _minHeight\n            });\n        } // Specify width and height in pixels\n        ;\n        _proto.size = function size(width, height) {\n            return this.withOptions({\n                width: width,\n                height: height\n            });\n        } // Specify blur between 0 and 100\n        ;\n        _proto.blur = function blur(_blur) {\n            return this.withOptions({\n                blur: _blur\n            });\n        };\n        _proto.sharpen = function sharpen(_sharpen) {\n            return this.withOptions({\n                sharpen: _sharpen\n            });\n        } // Specify the desired rectangle of the image\n        ;\n        _proto.rect = function rect(left, top, width, height) {\n            return this.withOptions({\n                rect: {\n                    left: left,\n                    top: top,\n                    width: width,\n                    height: height\n                }\n            });\n        } // Specify the image format of the image. 'jpg', 'pjpg', 'png', 'webp'\n        ;\n        _proto.format = function format(_format) {\n            return this.withOptions({\n                format: _format\n            });\n        };\n        _proto.invert = function invert(_invert) {\n            return this.withOptions({\n                invert: _invert\n            });\n        } // Rotation in degrees 0, 90, 180, 270\n        ;\n        _proto.orientation = function orientation(_orientation) {\n            return this.withOptions({\n                orientation: _orientation\n            });\n        } // Compression quality 0-100\n        ;\n        _proto.quality = function quality(_quality) {\n            return this.withOptions({\n                quality: _quality\n            });\n        } // Make it a download link. Parameter is default filename.\n        ;\n        _proto.forceDownload = function forceDownload(download) {\n            return this.withOptions({\n                download: download\n            });\n        } // Flip image horizontally\n        ;\n        _proto.flipHorizontal = function flipHorizontal() {\n            return this.withOptions({\n                flipHorizontal: true\n            });\n        } // Flip image vertically\n        ;\n        _proto.flipVertical = function flipVertical() {\n            return this.withOptions({\n                flipVertical: true\n            });\n        } // Ignore crop/hotspot from image record, even when present\n        ;\n        _proto.ignoreImageParams = function ignoreImageParams() {\n            return this.withOptions({\n                ignoreImageParams: true\n            });\n        };\n        _proto.fit = function fit(value) {\n            if (validFits.indexOf(value) === -1) {\n                throw new Error('Invalid fit mode \"' + value + '\"');\n            }\n            return this.withOptions({\n                fit: value\n            });\n        };\n        _proto.crop = function crop(value) {\n            if (validCrops.indexOf(value) === -1) {\n                throw new Error('Invalid crop mode \"' + value + '\"');\n            }\n            return this.withOptions({\n                crop: value\n            });\n        } // Saturation\n        ;\n        _proto.saturation = function saturation(_saturation) {\n            return this.withOptions({\n                saturation: _saturation\n            });\n        };\n        _proto.auto = function auto(value) {\n            if (validAutoModes.indexOf(value) === -1) {\n                throw new Error('Invalid auto mode \"' + value + '\"');\n            }\n            return this.withOptions({\n                auto: value\n            });\n        } // Specify the number of pixels to pad the image\n        ;\n        _proto.pad = function pad(_pad) {\n            return this.withOptions({\n                pad: _pad\n            });\n        } // Gets the url based on the submitted parameters\n        ;\n        _proto.url = function url() {\n            return urlForImage(this.options);\n        } // Alias for url()\n        ;\n        _proto.toString = function toString() {\n            return this.url();\n        };\n        return ImageUrlBuilder;\n    }();\n    return urlBuilder;\n}); //# sourceMappingURL=image-url.umd.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2ltYWdlLXVybC9saWIvYnJvd3Nlci9pbWFnZS11cmwudW1kLmpzIiwibWFwcGluZ3MiOiI7QUFBQyxVQUFVQSxNQUFNLEVBQUVDLE9BQU87SUFDeEIsS0FBaUQsR0FBY0UsT0FBT0QsT0FBTyxHQUFHRCxZQUNoRixDQUNrRTtBQUNwRSxHQUFHLFFBQU87SUFDUixTQUFTTztRQUNQQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBVUMsTUFBTTtZQUMxQyxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUMsVUFBVUMsTUFBTSxFQUFFRixJQUFLO2dCQUN6QyxJQUFJRyxTQUFTRixTQUFTLENBQUNELEVBQUU7Z0JBRXpCLElBQUssSUFBSUksT0FBT0QsT0FBUTtvQkFDdEIsSUFBSU4sT0FBT1EsU0FBUyxDQUFDQyxjQUFjLENBQUNDLElBQUksQ0FBQ0osUUFBUUMsTUFBTTt3QkFDckRMLE1BQU0sQ0FBQ0ssSUFBSSxHQUFHRCxNQUFNLENBQUNDLElBQUk7b0JBQzNCO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPTDtRQUNUO1FBRUEsT0FBT0gsU0FBU1ksS0FBSyxDQUFDLElBQUksRUFBRVA7SUFDOUI7SUFFQSxTQUFTUSw0QkFBNEJDLENBQUMsRUFBRUMsTUFBTTtRQUM1QyxJQUFJLENBQUNELEdBQUc7UUFDUixJQUFJLE9BQU9BLE1BQU0sVUFBVSxPQUFPRSxrQkFBa0JGLEdBQUdDO1FBQ3ZELElBQUlFLElBQUloQixPQUFPUSxTQUFTLENBQUNTLFFBQVEsQ0FBQ1AsSUFBSSxDQUFDRyxHQUFHSyxLQUFLLENBQUMsR0FBRyxDQUFDO1FBQ3BELElBQUlGLE1BQU0sWUFBWUgsRUFBRU0sV0FBVyxFQUFFSCxJQUFJSCxFQUFFTSxXQUFXLENBQUNDLElBQUk7UUFDM0QsSUFBSUosTUFBTSxTQUFTQSxNQUFNLE9BQU8sT0FBT0ssTUFBTUMsSUFBSSxDQUFDVDtRQUNsRCxJQUFJRyxNQUFNLGVBQWUsMkNB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QVUsR0FBRyxTQUFTQSxXQUFXQyxXQUFXO1lBQ2pELE9BQU8sSUFBSSxDQUFDaEMsV0FBVyxDQUFDO2dCQUN0QitCLFlBQVlDO1lBQ2Q7UUFDRjtRQUVBakMsT0FBT2tDLElBQUksR0FBRyxTQUFTQSxLQUFLekosS0FBSztZQUMvQixJQUFJaUcsZUFBZXFELE9BQU8sQ0FBQ3RKLFdBQVcsQ0FBQyxHQUFHO2dCQUN4QyxNQUFNLElBQUlVLE1BQU0sd0JBQXlCVixRQUFRO1lBQ25EO1lBRUEsT0FBTyxJQUFJLENBQUN3SCxXQUFXLENBQUM7Z0JBQ3RCaUMsTUFBTXpKO1lBQ1I7UUFDRixFQUFFLGdEQUFnRDs7UUFHbER1SCxPQUFPbUMsR0FBRyxHQUFHLFNBQVNBLElBQUlDLElBQUk7WUFDNUIsT0FBTyxJQUFJLENBQUNuQyxXQUFXLENBQUM7Z0JBQ3RCa0MsS0FBS0M7WUFDUDtRQUNGLEVBQUUsaURBQWlEOztRQUduRHBDLE9BQU85RixHQUFHLEdBQUcsU0FBU0E7WUFDcEIsT0FBT21CLFlBQVksSUFBSSxDQUFDQyxPQUFPO1FBQ2pDLEVBQUUsa0JBQWtCOztRQUdwQjBFLE9BQU8xSSxRQUFRLEdBQUcsU0FBU0E7WUFDekIsT0FBTyxJQUFJLENBQUM0QyxHQUFHO1FBQ2pCO1FBRUEsT0FBT3VGO0lBQ1Q7SUFFQSxPQUFPSjtBQUVULElBQ0EseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2ltYWdlLXVybC9saWIvYnJvd3Nlci9pbWFnZS11cmwudW1kLmpzPzM4Y2YiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5TYW5pdHlJbWFnZVVybEJ1aWxkZXIgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gICAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH07XG5cbiAgICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTtcbiAgICBpZiAoaXQpIHJldHVybiAoaXQgPSBpdC5jYWxsKG8pKS5uZXh0LmJpbmQoaXQpO1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgaWYgKGl0KSBvID0gaXQ7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG4gIH1cblxuICB2YXIgZXhhbXBsZSA9ICdpbWFnZS1UYjlFdzhDWEl3YVk2UjFrak12STB1UlItMjAwMHgzMDAwLWpwZyc7XG4gIGZ1bmN0aW9uIHBhcnNlQXNzZXRJZChyZWYpIHtcbiAgICB2YXIgX3JlZiRzcGxpdCA9IHJlZi5zcGxpdCgnLScpLFxuICAgICAgICBpZCA9IF9yZWYkc3BsaXRbMV0sXG4gICAgICAgIGRpbWVuc2lvblN0cmluZyA9IF9yZWYkc3BsaXRbMl0sXG4gICAgICAgIGZvcm1hdCA9IF9yZWYkc3BsaXRbM107XG5cbiAgICBpZiAoIWlkIHx8ICFkaW1lbnNpb25TdHJpbmcgfHwgIWZvcm1hdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIGFzc2V0IF9yZWYgJ1wiICsgcmVmICsgXCInLiBFeHBlY3RlZCBhbiBpZCBsaWtlIFxcXCJcIiArIGV4YW1wbGUgKyBcIlxcXCIuXCIpO1xuICAgIH1cblxuICAgIHZhciBfZGltZW5zaW9uU3RyaW5nJHNwbGkgPSBkaW1lbnNpb25TdHJpbmcuc3BsaXQoJ3gnKSxcbiAgICAgICAgaW1nV2lkdGhTdHIgPSBfZGltZW5zaW9uU3RyaW5nJHNwbGlbMF0sXG4gICAgICAgIGltZ0hlaWdodFN0ciA9IF9kaW1lbnNpb25TdHJpbmckc3BsaVsxXTtcblxuICAgIHZhciB3aWR0aCA9ICtpbWdXaWR0aFN0cjtcbiAgICB2YXIgaGVpZ2h0ID0gK2ltZ0hlaWdodFN0cjtcbiAgICB2YXIgaXNWYWxpZEFzc2V0SWQgPSBpc0Zpbml0ZSh3aWR0aCkgJiYgaXNGaW5pdGUoaGVpZ2h0KTtcblxuICAgIGlmICghaXNWYWxpZEFzc2V0SWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBhc3NldCBfcmVmICdcIiArIHJlZiArIFwiJy4gRXhwZWN0ZWQgYW4gaWQgbGlrZSBcXFwiXCIgKyBleGFtcGxlICsgXCJcXFwiLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGlkLFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBmb3JtYXQ6IGZvcm1hdFxuICAgIH07XG4gIH1cblxuICB2YXIgaXNSZWYgPSBmdW5jdGlvbiBpc1JlZihzcmMpIHtcbiAgICB2YXIgc291cmNlID0gc3JjO1xuICAgIHJldHVybiBzb3VyY2UgPyB0eXBlb2Ygc291cmNlLl9yZWYgPT09ICdzdHJpbmcnIDogZmFsc2U7XG4gIH07XG5cbiAgdmFyIGlzQXNzZXQgPSBmdW5jdGlvbiBpc0Fzc2V0KHNyYykge1xuICAgIHZhciBzb3VyY2UgPSBzcmM7XG4gICAgcmV0dXJuIHNvdXJjZSA/IHR5cGVvZiBzb3VyY2UuX2lkID09PSAnc3RyaW5nJyA6IGZhbHNlO1xuICB9O1xuXG4gIHZhciBpc0Fzc2V0U3R1YiA9IGZ1bmN0aW9uIGlzQXNzZXRTdHViKHNyYykge1xuICAgIHZhciBzb3VyY2UgPSBzcmM7XG4gICAgcmV0dXJuIHNvdXJjZSAmJiBzb3VyY2UuYXNzZXQgPyB0eXBlb2Ygc291cmNlLmFzc2V0LnVybCA9PT0gJ3N0cmluZycgOiBmYWxzZTtcbiAgfTsgLy8gQ29udmVydCBhbiBhc3NldC1pZCwgYXNzZXQgb3IgaW1hZ2UgdG8gYW4gaW1hZ2UgcmVjb3JkIHN1aXRhYmxlIGZvciBwcm9jZXNzaW5nXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cblxuICBmdW5jdGlvbiBwYXJzZVNvdXJjZShzb3VyY2UpIHtcbiAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGltYWdlO1xuXG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmIGlzVXJsKHNvdXJjZSkpIHtcbiAgICAgIC8vIFNvbWVvbmUgcGFzc2VkIGFuIGV4aXN0aW5nIGltYWdlIHVybD9cbiAgICAgIGltYWdlID0ge1xuICAgICAgICBhc3NldDoge1xuICAgICAgICAgIF9yZWY6IHVybFRvSWQoc291cmNlKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIEp1c3QgYW4gYXNzZXQgaWRcbiAgICAgIGltYWdlID0ge1xuICAgICAgICBhc3NldDoge1xuICAgICAgICAgIF9yZWY6IHNvdXJjZVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXNSZWYoc291cmNlKSkge1xuICAgICAgLy8gV2UganVzdCBnb3QgcGFzc2VkIGFuIGFzc2V0IGRpcmVjdGx5XG4gICAgICBpbWFnZSA9IHtcbiAgICAgICAgYXNzZXQ6IHNvdXJjZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzQXNzZXQoc291cmNlKSkge1xuICAgICAgLy8gSWYgd2Ugd2VyZSBwYXNzZWQgYW4gaW1hZ2UgYXNzZXQgZG9jdW1lbnRcbiAgICAgIGltYWdlID0ge1xuICAgICAgICBhc3NldDoge1xuICAgICAgICAgIF9yZWY6IHNvdXJjZS5faWQgfHwgJydcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGlzQXNzZXRTdHViKHNvdXJjZSkpIHtcbiAgICAgIC8vIElmIHdlIHdlcmUgcGFzc2VkIGEgcGFydGlhbCBhc3NldCAoYHVybGAsIGJ1dCBubyBgX2lkYClcbiAgICAgIGltYWdlID0ge1xuICAgICAgICBhc3NldDoge1xuICAgICAgICAgIF9yZWY6IHVybFRvSWQoc291cmNlLmFzc2V0LnVybClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzb3VyY2UuYXNzZXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBQcm9iYWJseSBhbiBhY3R1YWwgaW1hZ2Ugd2l0aCBtYXRlcmlhbGl6ZWQgYXNzZXRcbiAgICAgIGltYWdlID0gX2V4dGVuZHMoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIGdvdCBzb21ldGhpbmcgdGhhdCBkb2VzIG5vdCBsb29rIGxpa2UgYW4gaW1hZ2UsIG9yIGl0IGlzIGFuIGltYWdlXG4gICAgICAvLyB0aGF0IGN1cnJlbnRseSBpc24ndCBzcG9ydGluZyBhbiBhc3NldC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBpbWcgPSBzb3VyY2U7XG5cbiAgICBpZiAoaW1nLmNyb3ApIHtcbiAgICAgIGltYWdlLmNyb3AgPSBpbWcuY3JvcDtcbiAgICB9XG5cbiAgICBpZiAoaW1nLmhvdHNwb3QpIHtcbiAgICAgIGltYWdlLmhvdHNwb3QgPSBpbWcuaG90c3BvdDtcbiAgICB9XG5cbiAgICByZXR1cm4gYXBwbHlEZWZhdWx0cyhpbWFnZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc1VybCh1cmwpIHtcbiAgICByZXR1cm4gL15odHRwcz86XFwvXFwvLy50ZXN0KFwiXCIgKyB1cmwpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXJsVG9JZCh1cmwpIHtcbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJy8nKS5zbGljZSgtMSk7XG4gICAgcmV0dXJuIChcImltYWdlLVwiICsgcGFydHNbMF0pLnJlcGxhY2UoL1xcLihbYS16XSspJC8sICctJDEnKTtcbiAgfSAvLyBNb2NrIGNyb3AgYW5kIGhvdHNwb3QgaWYgaW1hZ2UgbGFja3MgaXRcblxuXG4gIGZ1bmN0aW9uIGFwcGx5RGVmYXVsdHMoaW1hZ2UpIHtcbiAgICBpZiAoaW1hZ2UuY3JvcCAmJiBpbWFnZS5ob3RzcG90KSB7XG4gICAgICByZXR1cm4gaW1hZ2U7XG4gICAgfSAvLyBXZSBuZWVkIHRvIHBhZCBpbiBkZWZhdWx0IHZhbHVlcyBmb3IgY3JvcCBvciBob3RzcG90XG5cblxuICAgIHZhciByZXN1bHQgPSBfZXh0ZW5kcyh7fSwgaW1hZ2UpO1xuXG4gICAgaWYgKCFyZXN1bHQuY3JvcCkge1xuICAgICAgcmVzdWx0LmNyb3AgPSB7XG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICByaWdodDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoIXJlc3VsdC5ob3RzcG90KSB7XG4gICAgICByZXN1bHQuaG90c3BvdCA9IHtcbiAgICAgICAgeDogMC41LFxuICAgICAgICB5OiAwLjUsXG4gICAgICAgIGhlaWdodDogMS4wLFxuICAgICAgICB3aWR0aDogMS4wXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgU1BFQ19OQU1FX1RPX1VSTF9OQU1FX01BUFBJTkdTID0gW1snd2lkdGgnLCAndyddLCBbJ2hlaWdodCcsICdoJ10sIFsnZm9ybWF0JywgJ2ZtJ10sIFsnZG93bmxvYWQnLCAnZGwnXSwgWydibHVyJywgJ2JsdXInXSwgWydzaGFycGVuJywgJ3NoYXJwJ10sIFsnaW52ZXJ0JywgJ2ludmVydCddLCBbJ29yaWVudGF0aW9uJywgJ29yJ10sIFsnbWluSGVpZ2h0JywgJ21pbi1oJ10sIFsnbWF4SGVpZ2h0JywgJ21heC1oJ10sIFsnbWluV2lkdGgnLCAnbWluLXcnXSwgWydtYXhXaWR0aCcsICdtYXgtdyddLCBbJ3F1YWxpdHknLCAncSddLCBbJ2ZpdCcsICdmaXQnXSwgWydjcm9wJywgJ2Nyb3AnXSwgWydzYXR1cmF0aW9uJywgJ3NhdCddLCBbJ2F1dG8nLCAnYXV0byddLCBbJ2RwcicsICdkcHInXSwgWydwYWQnLCAncGFkJ11dO1xuICBmdW5jdGlvbiB1cmxGb3JJbWFnZShvcHRpb25zKSB7XG4gICAgdmFyIHNwZWMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyB8fCB7fSk7XG5cbiAgICB2YXIgc291cmNlID0gc3BlYy5zb3VyY2U7XG4gICAgZGVsZXRlIHNwZWMuc291cmNlO1xuICAgIHZhciBpbWFnZSA9IHBhcnNlU291cmNlKHNvdXJjZSk7XG5cbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gcmVzb2x2ZSBpbWFnZSBVUkwgZnJvbSBzb3VyY2UgKFwiICsgSlNPTi5zdHJpbmdpZnkoc291cmNlKSArIFwiKVwiKTtcbiAgICB9XG5cbiAgICB2YXIgaWQgPSBpbWFnZS5hc3NldC5fcmVmIHx8IGltYWdlLmFzc2V0Ll9pZCB8fCAnJztcbiAgICB2YXIgYXNzZXQgPSBwYXJzZUFzc2V0SWQoaWQpOyAvLyBDb21wdXRlIGNyb3AgcmVjdCBpbiB0ZXJtcyBvZiBwaXhlbCBjb29yZGluYXRlcyBpbiB0aGUgcmF3IHNvdXJjZSBpbWFnZVxuXG4gICAgdmFyIGNyb3BMZWZ0ID0gTWF0aC5yb3VuZChpbWFnZS5jcm9wLmxlZnQgKiBhc3NldC53aWR0aCk7XG4gICAgdmFyIGNyb3BUb3AgPSBNYXRoLnJvdW5kKGltYWdlLmNyb3AudG9wICogYXNzZXQuaGVpZ2h0KTtcbiAgICB2YXIgY3JvcCA9IHtcbiAgICAgIGxlZnQ6IGNyb3BMZWZ0LFxuICAgICAgdG9wOiBjcm9wVG9wLFxuICAgICAgd2lkdGg6IE1hdGgucm91bmQoYXNzZXQud2lkdGggLSBpbWFnZS5jcm9wLnJpZ2h0ICogYXNzZXQud2lkdGggLSBjcm9wTGVmdCksXG4gICAgICBoZWlnaHQ6IE1hdGgucm91bmQoYXNzZXQuaGVpZ2h0IC0gaW1hZ2UuY3JvcC5ib3R0b20gKiBhc3NldC5oZWlnaHQgLSBjcm9wVG9wKVxuICAgIH07IC8vIENvbXB1dGUgaG90IHNwb3QgcmVjdCBpbiB0ZXJtcyBvZiBwaXhlbCBjb29yZGluYXRlc1xuXG4gICAgdmFyIGhvdFNwb3RWZXJ0aWNhbFJhZGl1cyA9IGltYWdlLmhvdHNwb3QuaGVpZ2h0ICogYXNzZXQuaGVpZ2h0IC8gMjtcbiAgICB2YXIgaG90U3BvdEhvcml6b250YWxSYWRpdXMgPSBpbWFnZS5ob3RzcG90LndpZHRoICogYXNzZXQud2lkdGggLyAyO1xuICAgIHZhciBob3RTcG90Q2VudGVyWCA9IGltYWdlLmhvdHNwb3QueCAqIGFzc2V0LndpZHRoO1xuICAgIHZhciBob3RTcG90Q2VudGVyWSA9IGltYWdlLmhvdHNwb3QueSAqIGFzc2V0LmhlaWdodDtcbiAgICB2YXIgaG90c3BvdCA9IHtcbiAgICAgIGxlZnQ6IGhvdFNwb3RDZW50ZXJYIC0gaG90U3BvdEhvcml6b250YWxSYWRpdXMsXG4gICAgICB0b3A6IGhvdFNwb3RDZW50ZXJZIC0gaG90U3BvdFZlcnRpY2FsUmFkaXVzLFxuICAgICAgcmlnaHQ6IGhvdFNwb3RDZW50ZXJYICsgaG90U3BvdEhvcml6b250YWxSYWRpdXMsXG4gICAgICBib3R0b206IGhvdFNwb3RDZW50ZXJZICsgaG90U3BvdFZlcnRpY2FsUmFkaXVzXG4gICAgfTsgLy8gSWYgaXJyZWxldmFudCwgb3IgaWYgd2UgYXJlIHJlcXVlc3RlZCB0bzogZG9uJ3QgcGVyZm9ybSBjcm9wL2ZpdCBiYXNlZCBvblxuICAgIC8vIHRoZSBjcm9wL2hvdHNwb3QuXG5cbiAgICBpZiAoIShzcGVjLnJlY3QgfHwgc3BlYy5mb2NhbFBvaW50IHx8IHNwZWMuaWdub3JlSW1hZ2VQYXJhbXMgfHwgc3BlYy5jcm9wKSkge1xuICAgICAgc3BlYyA9IF9leHRlbmRzKHt9LCBzcGVjLCBmaXQoe1xuICAgICAgICBjcm9wOiBjcm9wLFxuICAgICAgICBob3RzcG90OiBob3RzcG90XG4gICAgICB9LCBzcGVjKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNwZWNUb0ltYWdlVXJsKF9leHRlbmRzKHt9LCBzcGVjLCB7XG4gICAgICBhc3NldDogYXNzZXRcbiAgICB9KSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcblxuICBmdW5jdGlvbiBzcGVjVG9JbWFnZVVybChzcGVjKSB7XG4gICAgdmFyIGNkblVybCA9IChzcGVjLmJhc2VVcmwgfHwgJ2h0dHBzOi8vY2RuLnNhbml0eS5pbycpLnJlcGxhY2UoL1xcLyskLywgJycpO1xuICAgIHZhciBmaWxlbmFtZSA9IHNwZWMuYXNzZXQuaWQgKyBcIi1cIiArIHNwZWMuYXNzZXQud2lkdGggKyBcInhcIiArIHNwZWMuYXNzZXQuaGVpZ2h0ICsgXCIuXCIgKyBzcGVjLmFzc2V0LmZvcm1hdDtcbiAgICB2YXIgYmFzZVVybCA9IGNkblVybCArIFwiL2ltYWdlcy9cIiArIHNwZWMucHJvamVjdElkICsgXCIvXCIgKyBzcGVjLmRhdGFzZXQgKyBcIi9cIiArIGZpbGVuYW1lO1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGlmIChzcGVjLnJlY3QpIHtcbiAgICAgIC8vIE9ubHkgYm90aGVyIHVybCB3aXRoIGEgY3JvcCBpZiBpdCBhY3R1YWxseSBjcm9wcyBhbnl0aGluZ1xuICAgICAgdmFyIF9zcGVjJHJlY3QgPSBzcGVjLnJlY3QsXG4gICAgICAgICAgbGVmdCA9IF9zcGVjJHJlY3QubGVmdCxcbiAgICAgICAgICB0b3AgPSBfc3BlYyRyZWN0LnRvcCxcbiAgICAgICAgICB3aWR0aCA9IF9zcGVjJHJlY3Qud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gX3NwZWMkcmVjdC5oZWlnaHQ7XG4gICAgICB2YXIgaXNFZmZlY3RpdmVDcm9wID0gbGVmdCAhPT0gMCB8fCB0b3AgIT09IDAgfHwgaGVpZ2h0ICE9PSBzcGVjLmFzc2V0LmhlaWdodCB8fCB3aWR0aCAhPT0gc3BlYy5hc3NldC53aWR0aDtcblxuICAgICAgaWYgKGlzRWZmZWN0aXZlQ3JvcCkge1xuICAgICAgICBwYXJhbXMucHVzaChcInJlY3Q9XCIgKyBsZWZ0ICsgXCIsXCIgKyB0b3AgKyBcIixcIiArIHdpZHRoICsgXCIsXCIgKyBoZWlnaHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzcGVjLmJnKSB7XG4gICAgICBwYXJhbXMucHVzaChcImJnPVwiICsgc3BlYy5iZyk7XG4gICAgfVxuXG4gICAgaWYgKHNwZWMuZm9jYWxQb2ludCkge1xuICAgICAgcGFyYW1zLnB1c2goXCJmcC14PVwiICsgc3BlYy5mb2NhbFBvaW50LngpO1xuICAgICAgcGFyYW1zLnB1c2goXCJmcC15PVwiICsgc3BlYy5mb2NhbFBvaW50LnkpO1xuICAgIH1cblxuICAgIHZhciBmbGlwID0gW3NwZWMuZmxpcEhvcml6b250YWwgJiYgJ2gnLCBzcGVjLmZsaXBWZXJ0aWNhbCAmJiAndiddLmZpbHRlcihCb29sZWFuKS5qb2luKCcnKTtcblxuICAgIGlmIChmbGlwKSB7XG4gICAgICBwYXJhbXMucHVzaChcImZsaXA9XCIgKyBmbGlwKTtcbiAgICB9IC8vIE1hcCBmcm9tIHNwZWMgbmFtZSB0byB1cmwgcGFyYW0gbmFtZSwgYW5kIGFsbG93IHVzaW5nIHRoZSBhY3R1YWwgcGFyYW0gbmFtZSBhcyBhbiBhbHRlcm5hdGl2ZVxuXG5cbiAgICBTUEVDX05BTUVfVE9fVVJMX05BTUVfTUFQUElOR1MuZm9yRWFjaChmdW5jdGlvbiAobWFwcGluZykge1xuICAgICAgdmFyIHNwZWNOYW1lID0gbWFwcGluZ1swXSxcbiAgICAgICAgICBwYXJhbSA9IG1hcHBpbmdbMV07XG5cbiAgICAgIGlmICh0eXBlb2Ygc3BlY1tzcGVjTmFtZV0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoc3BlY1tzcGVjTmFtZV0pKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHNwZWNbcGFyYW1dICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJhbXMucHVzaChwYXJhbSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHNwZWNbcGFyYW1dKSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJhc2VVcmw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJhc2VVcmwgKyBcIj9cIiArIHBhcmFtcy5qb2luKCcmJyk7XG4gIH1cblxuICBmdW5jdGlvbiBmaXQoc291cmNlLCBzcGVjKSB7XG4gICAgdmFyIGNyb3BSZWN0O1xuICAgIHZhciBpbWdXaWR0aCA9IHNwZWMud2lkdGg7XG4gICAgdmFyIGltZ0hlaWdodCA9IHNwZWMuaGVpZ2h0OyAvLyBJZiB3ZSBhcmUgbm90IGNvbnN0cmFpbmluZyB0aGUgYXNwZWN0IHJhdGlvLCB3ZSdsbCBqdXN0IHVzZSB0aGUgd2hvbGUgY3JvcFxuXG4gICAgaWYgKCEoaW1nV2lkdGggJiYgaW1nSGVpZ2h0KSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IGltZ1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IGltZ0hlaWdodCxcbiAgICAgICAgcmVjdDogc291cmNlLmNyb3BcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNyb3AgPSBzb3VyY2UuY3JvcDtcbiAgICB2YXIgaG90c3BvdCA9IHNvdXJjZS5ob3RzcG90OyAvLyBJZiB3ZSBhcmUgaGVyZSwgdGhhdCBtZWFucyBhc3BlY3QgcmF0aW8gaXMgbG9ja2VkIGFuZCBmaXR0aW5nIHdpbGwgYmUgYSBiaXQgaGFyZGVyXG5cbiAgICB2YXIgZGVzaXJlZEFzcGVjdFJhdGlvID0gaW1nV2lkdGggLyBpbWdIZWlnaHQ7XG4gICAgdmFyIGNyb3BBc3BlY3RSYXRpbyA9IGNyb3Aud2lkdGggLyBjcm9wLmhlaWdodDtcblxuICAgIGlmIChjcm9wQXNwZWN0UmF0aW8gPiBkZXNpcmVkQXNwZWN0UmF0aW8pIHtcbiAgICAgIC8vIFRoZSBjcm9wIGlzIHdpZGVyIHRoYW4gdGhlIGRlc2lyZWQgYXNwZWN0IHJhdGlvLiBUaGF0IG1lYW5zIHdlIGFyZSBjdXR0aW5nIGZyb20gdGhlIHNpZGVzXG4gICAgICB2YXIgaGVpZ2h0ID0gTWF0aC5yb3VuZChjcm9wLmhlaWdodCk7XG4gICAgICB2YXIgd2lkdGggPSBNYXRoLnJvdW5kKGhlaWdodCAqIGRlc2lyZWRBc3BlY3RSYXRpbyk7XG4gICAgICB2YXIgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChjcm9wLnRvcCkpOyAvLyBDZW50ZXIgb3V0cHV0IGhvcml6b250YWxseSBvdmVyIGhvdHNwb3RcblxuICAgICAgdmFyIGhvdHNwb3RYQ2VudGVyID0gTWF0aC5yb3VuZCgoaG90c3BvdC5yaWdodCAtIGhvdHNwb3QubGVmdCkgLyAyICsgaG90c3BvdC5sZWZ0KTtcbiAgICAgIHZhciBsZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChob3RzcG90WENlbnRlciAtIHdpZHRoIC8gMikpOyAvLyBLZWVwIG91dHB1dCB3aXRoaW4gY3JvcFxuXG4gICAgICBpZiAobGVmdCA8IGNyb3AubGVmdCkge1xuICAgICAgICBsZWZ0ID0gY3JvcC5sZWZ0O1xuICAgICAgfSBlbHNlIGlmIChsZWZ0ICsgd2lkdGggPiBjcm9wLmxlZnQgKyBjcm9wLndpZHRoKSB7XG4gICAgICAgIGxlZnQgPSBjcm9wLmxlZnQgKyBjcm9wLndpZHRoIC0gd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGNyb3BSZWN0ID0ge1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIGNyb3AgaXMgdGFsbGVyIHRoYW4gdGhlIGRlc2lyZWQgcmF0aW8sIHdlIGFyZSBjdXR0aW5nIGZyb20gdG9wIGFuZCBib3R0b21cbiAgICAgIHZhciBfd2lkdGggPSBjcm9wLndpZHRoO1xuXG4gICAgICB2YXIgX2hlaWdodCA9IE1hdGgucm91bmQoX3dpZHRoIC8gZGVzaXJlZEFzcGVjdFJhdGlvKTtcblxuICAgICAgdmFyIF9sZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZChjcm9wLmxlZnQpKTsgLy8gQ2VudGVyIG91dHB1dCB2ZXJ0aWNhbGx5IG92ZXIgaG90c3BvdFxuXG5cbiAgICAgIHZhciBob3RzcG90WUNlbnRlciA9IE1hdGgucm91bmQoKGhvdHNwb3QuYm90dG9tIC0gaG90c3BvdC50b3ApIC8gMiArIGhvdHNwb3QudG9wKTtcblxuICAgICAgdmFyIF90b3AgPSBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKGhvdHNwb3RZQ2VudGVyIC0gX2hlaWdodCAvIDIpKTsgLy8gS2VlcCBvdXRwdXQgcmVjdCB3aXRoaW4gY3JvcFxuXG5cbiAgICAgIGlmIChfdG9wIDwgY3JvcC50b3ApIHtcbiAgICAgICAgX3RvcCA9IGNyb3AudG9wO1xuICAgICAgfSBlbHNlIGlmIChfdG9wICsgX2hlaWdodCA+IGNyb3AudG9wICsgY3JvcC5oZWlnaHQpIHtcbiAgICAgICAgX3RvcCA9IGNyb3AudG9wICsgY3JvcC5oZWlnaHQgLSBfaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICBjcm9wUmVjdCA9IHtcbiAgICAgICAgbGVmdDogX2xlZnQsXG4gICAgICAgIHRvcDogX3RvcCxcbiAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogaW1nV2lkdGgsXG4gICAgICBoZWlnaHQ6IGltZ0hlaWdodCxcbiAgICAgIHJlY3Q6IGNyb3BSZWN0XG4gICAgfTtcbiAgfSAvLyBGb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcblxuICB2YXIgdmFsaWRGaXRzID0gWydjbGlwJywgJ2Nyb3AnLCAnZmlsbCcsICdmaWxsbWF4JywgJ21heCcsICdzY2FsZScsICdtaW4nXTtcbiAgdmFyIHZhbGlkQ3JvcHMgPSBbJ3RvcCcsICdib3R0b20nLCAnbGVmdCcsICdyaWdodCcsICdjZW50ZXInLCAnZm9jYWxwb2ludCcsICdlbnRyb3B5J107XG4gIHZhciB2YWxpZEF1dG9Nb2RlcyA9IFsnZm9ybWF0J107XG5cbiAgZnVuY3Rpb24gaXNTYW5pdHlNb2Rlcm5DbGllbnRMaWtlKGNsaWVudCkge1xuICAgIHJldHVybiBjbGllbnQgJiYgJ2NvbmZpZycgaW4gY2xpZW50ID8gdHlwZW9mIGNsaWVudC5jb25maWcgPT09ICdmdW5jdGlvbicgOiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU2FuaXR5Q2xpZW50TGlrZShjbGllbnQpIHtcbiAgICByZXR1cm4gY2xpZW50ICYmICdjbGllbnRDb25maWcnIGluIGNsaWVudCA/IHR5cGVvZiBjbGllbnQuY2xpZW50Q29uZmlnID09PSAnb2JqZWN0JyA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV3cml0ZVNwZWNOYW1lKGtleSkge1xuICAgIHZhciBzcGVjcyA9IFNQRUNfTkFNRV9UT19VUkxfTkFNRV9NQVBQSU5HUztcblxuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2Uoc3BlY3MpLCBfc3RlcDsgIShfc3RlcCA9IF9pdGVyYXRvcigpKS5kb25lOykge1xuICAgICAgdmFyIGVudHJ5ID0gX3N0ZXAudmFsdWU7XG4gICAgICB2YXIgc3BlY05hbWUgPSBlbnRyeVswXSxcbiAgICAgICAgICBwYXJhbSA9IGVudHJ5WzFdO1xuXG4gICAgICBpZiAoa2V5ID09PSBzcGVjTmFtZSB8fCBrZXkgPT09IHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBzcGVjTmFtZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga2V5O1xuICB9XG5cbiAgZnVuY3Rpb24gdXJsQnVpbGRlcihvcHRpb25zKSB7XG4gICAgLy8gRGlkIHdlIGdldCBhIG1vZGVybmlzaCBjbGllbnQ/XG4gICAgaWYgKGlzU2FuaXR5TW9kZXJuQ2xpZW50TGlrZShvcHRpb25zKSkge1xuICAgICAgLy8gSW5oZXJpdCBjb25maWcgZnJvbSBjbGllbnRcbiAgICAgIHZhciBfb3B0aW9ucyRjb25maWcgPSBvcHRpb25zLmNvbmZpZygpLFxuICAgICAgICAgIGFwaVVybCA9IF9vcHRpb25zJGNvbmZpZy5hcGlIb3N0LFxuICAgICAgICAgIHByb2plY3RJZCA9IF9vcHRpb25zJGNvbmZpZy5wcm9qZWN0SWQsXG4gICAgICAgICAgZGF0YXNldCA9IF9vcHRpb25zJGNvbmZpZy5kYXRhc2V0O1xuXG4gICAgICB2YXIgYXBpSG9zdCA9IGFwaVVybCB8fCAnaHR0cHM6Ly9hcGkuc2FuaXR5LmlvJztcbiAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIHtcbiAgICAgICAgYmFzZVVybDogYXBpSG9zdC5yZXBsYWNlKC9eaHR0cHM6XFwvXFwvYXBpXFwuLywgJ2h0dHBzOi8vY2RuLicpLFxuICAgICAgICBwcm9qZWN0SWQ6IHByb2plY3RJZCxcbiAgICAgICAgZGF0YXNldDogZGF0YXNldFxuICAgICAgfSk7XG4gICAgfSAvLyBEaWQgd2UgZ2V0IGEgU2FuaXR5Q2xpZW50P1xuXG5cbiAgICB2YXIgY2xpZW50ID0gb3B0aW9ucztcblxuICAgIGlmIChpc1Nhbml0eUNsaWVudExpa2UoY2xpZW50KSkge1xuICAgICAgLy8gSW5oZXJpdCBjb25maWcgZnJvbSBjbGllbnRcbiAgICAgIHZhciBfY2xpZW50JGNsaWVudENvbmZpZyA9IGNsaWVudC5jbGllbnRDb25maWcsXG4gICAgICAgICAgX2FwaVVybCA9IF9jbGllbnQkY2xpZW50Q29uZmlnLmFwaUhvc3QsXG4gICAgICAgICAgX3Byb2plY3RJZCA9IF9jbGllbnQkY2xpZW50Q29uZmlnLnByb2plY3RJZCxcbiAgICAgICAgICBfZGF0YXNldCA9IF9jbGllbnQkY2xpZW50Q29uZmlnLmRhdGFzZXQ7XG5cbiAgICAgIHZhciBfYXBpSG9zdCA9IF9hcGlVcmwgfHwgJ2h0dHBzOi8vYXBpLnNhbml0eS5pbyc7XG5cbiAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKG51bGwsIHtcbiAgICAgICAgYmFzZVVybDogX2FwaUhvc3QucmVwbGFjZSgvXmh0dHBzOlxcL1xcL2FwaVxcLi8sICdodHRwczovL2Nkbi4nKSxcbiAgICAgICAgcHJvamVjdElkOiBfcHJvamVjdElkLFxuICAgICAgICBkYXRhc2V0OiBfZGF0YXNldFxuICAgICAgfSk7XG4gICAgfSAvLyBPciBqdXN0IGFjY2VwdCB0aGUgb3B0aW9ucyBhcyBnaXZlblxuXG5cbiAgICByZXR1cm4gbmV3IEltYWdlVXJsQnVpbGRlcihudWxsLCBvcHRpb25zKTtcbiAgfVxuICB2YXIgSW1hZ2VVcmxCdWlsZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbWFnZVVybEJ1aWxkZXIocGFyZW50LCBvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB2b2lkIDA7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBwYXJlbnQgPyBfZXh0ZW5kcyh7fSwgcGFyZW50Lm9wdGlvbnMgfHwge30sIG9wdGlvbnMgfHwge30pIC8vIE1lcmdlIHBhcmVudCBvcHRpb25zXG4gICAgICA6IF9leHRlbmRzKHt9LCBvcHRpb25zIHx8IHt9KTsgLy8gQ29weSBvcHRpb25zXG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEltYWdlVXJsQnVpbGRlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8ud2l0aE9wdGlvbnMgPSBmdW5jdGlvbiB3aXRoT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICB2YXIgYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybCB8fCB0aGlzLm9wdGlvbnMuYmFzZVVybDtcbiAgICAgIHZhciBuZXdPcHRpb25zID0ge1xuICAgICAgICBiYXNlVXJsOiBiYXNlVXJsXG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIHNwZWNLZXkgPSByZXdyaXRlU3BlY05hbWUoa2V5KTtcbiAgICAgICAgICBuZXdPcHRpb25zW3NwZWNLZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgSW1hZ2VVcmxCdWlsZGVyKHRoaXMsIF9leHRlbmRzKHtcbiAgICAgICAgYmFzZVVybDogYmFzZVVybFxuICAgICAgfSwgbmV3T3B0aW9ucykpO1xuICAgIH0gLy8gVGhlIGltYWdlIHRvIGJlIHJlcHJlc2VudGVkLiBBY2NlcHRzIGEgU2FuaXR5ICdpbWFnZSctZG9jdW1lbnQsICdhc3NldCctZG9jdW1lbnQgb3JcbiAgICAvLyBfaWQgb2YgYXNzZXQuIFRvIGdldCB0aGUgYmVuZWZpdCBvZiBhdXRvbWF0aWMgaG90LXNwb3QvY3JvcCBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBjb250ZW50XG4gICAgLy8gc3R1ZGlvLCB0aGUgJ2ltYWdlJy1kb2N1bWVudCBtdXN0IGJlIHByb3ZpZGVkLlxuICAgIDtcblxuICAgIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZVxuICAgICAgfSk7XG4gICAgfSAvLyBTcGVjaWZ5IHRoZSBkYXRhc2V0XG4gICAgO1xuXG4gICAgX3Byb3RvLmRhdGFzZXQgPSBmdW5jdGlvbiBkYXRhc2V0KF9kYXRhc2V0Mikge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBkYXRhc2V0OiBfZGF0YXNldDJcbiAgICAgIH0pO1xuICAgIH0gLy8gU3BlY2lmeSB0aGUgcHJvamVjdElkXG4gICAgO1xuXG4gICAgX3Byb3RvLnByb2plY3RJZCA9IGZ1bmN0aW9uIHByb2plY3RJZChfcHJvamVjdElkMikge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBwcm9qZWN0SWQ6IF9wcm9qZWN0SWQyXG4gICAgICB9KTtcbiAgICB9IC8vIFNwZWNpZnkgYmFja2dyb3VuZCBjb2xvclxuICAgIDtcblxuICAgIF9wcm90by5iZyA9IGZ1bmN0aW9uIGJnKF9iZykge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBiZzogX2JnXG4gICAgICB9KTtcbiAgICB9IC8vIFNldCBEUFIgc2NhbGluZyBmYWN0b3JcbiAgICA7XG5cbiAgICBfcHJvdG8uZHByID0gZnVuY3Rpb24gZHByKF9kcHIpIHtcbiAgICAgIC8vIEEgRFBSIG9mIDEgaXMgdGhlIGRlZmF1bHQgLSBzbyBvbmx5IGluY2x1ZGUgaXQgaWYgd2UgaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZVxuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoX2RwciAmJiBfZHByICE9PSAxID8ge1xuICAgICAgICBkcHI6IF9kcHJcbiAgICAgIH0gOiB7fSk7XG4gICAgfSAvLyBTcGVjaWZ5IHRoZSB3aWR0aCBvZiB0aGUgaW1hZ2UgaW4gcGl4ZWxzXG4gICAgO1xuXG4gICAgX3Byb3RvLndpZHRoID0gZnVuY3Rpb24gd2lkdGgoX3dpZHRoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIHdpZHRoOiBfd2lkdGhcbiAgICAgIH0pO1xuICAgIH0gLy8gU3BlY2lmeSB0aGUgaGVpZ2h0IG9mIHRoZSBpbWFnZSBpbiBwaXhlbHNcbiAgICA7XG5cbiAgICBfcHJvdG8uaGVpZ2h0ID0gZnVuY3Rpb24gaGVpZ2h0KF9oZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9IC8vIFNwZWNpZnkgZm9jYWwgcG9pbnQgaW4gZnJhY3Rpb24gb2YgaW1hZ2UgZGltZW5zaW9ucy4gRWFjaCBjb21wb25lbnQgMC4wLTEuMFxuICAgIDtcblxuICAgIF9wcm90by5mb2NhbFBvaW50ID0gZnVuY3Rpb24gZm9jYWxQb2ludCh4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIGZvY2FsUG9pbnQ6IHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5tYXhXaWR0aCA9IGZ1bmN0aW9uIG1heFdpZHRoKF9tYXhXaWR0aCkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBtYXhXaWR0aDogX21heFdpZHRoXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLm1pbldpZHRoID0gZnVuY3Rpb24gbWluV2lkdGgoX21pbldpZHRoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIG1pbldpZHRoOiBfbWluV2lkdGhcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8ubWF4SGVpZ2h0ID0gZnVuY3Rpb24gbWF4SGVpZ2h0KF9tYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgbWF4SGVpZ2h0OiBfbWF4SGVpZ2h0XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLm1pbkhlaWdodCA9IGZ1bmN0aW9uIG1pbkhlaWdodChfbWluSGVpZ2h0KSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIG1pbkhlaWdodDogX21pbkhlaWdodFxuICAgICAgfSk7XG4gICAgfSAvLyBTcGVjaWZ5IHdpZHRoIGFuZCBoZWlnaHQgaW4gcGl4ZWxzXG4gICAgO1xuXG4gICAgX3Byb3RvLnNpemUgPSBmdW5jdGlvbiBzaXplKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgfSAvLyBTcGVjaWZ5IGJsdXIgYmV0d2VlbiAwIGFuZCAxMDBcbiAgICA7XG5cbiAgICBfcHJvdG8uYmx1ciA9IGZ1bmN0aW9uIGJsdXIoX2JsdXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgYmx1cjogX2JsdXJcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc2hhcnBlbiA9IGZ1bmN0aW9uIHNoYXJwZW4oX3NoYXJwZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgc2hhcnBlbjogX3NoYXJwZW5cbiAgICAgIH0pO1xuICAgIH0gLy8gU3BlY2lmeSB0aGUgZGVzaXJlZCByZWN0YW5nbGUgb2YgdGhlIGltYWdlXG4gICAgO1xuXG4gICAgX3Byb3RvLnJlY3QgPSBmdW5jdGlvbiByZWN0KGxlZnQsIHRvcCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICByZWN0OiB7XG4gICAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSAvLyBTcGVjaWZ5IHRoZSBpbWFnZSBmb3JtYXQgb2YgdGhlIGltYWdlLiAnanBnJywgJ3BqcGcnLCAncG5nJywgJ3dlYnAnXG4gICAgO1xuXG4gICAgX3Byb3RvLmZvcm1hdCA9IGZ1bmN0aW9uIGZvcm1hdChfZm9ybWF0KSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIGZvcm1hdDogX2Zvcm1hdFxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoX2ludmVydCkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBpbnZlcnQ6IF9pbnZlcnRcbiAgICAgIH0pO1xuICAgIH0gLy8gUm90YXRpb24gaW4gZGVncmVlcyAwLCA5MCwgMTgwLCAyNzBcbiAgICA7XG5cbiAgICBfcHJvdG8ub3JpZW50YXRpb24gPSBmdW5jdGlvbiBvcmllbnRhdGlvbihfb3JpZW50YXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgb3JpZW50YXRpb246IF9vcmllbnRhdGlvblxuICAgICAgfSk7XG4gICAgfSAvLyBDb21wcmVzc2lvbiBxdWFsaXR5IDAtMTAwXG4gICAgO1xuXG4gICAgX3Byb3RvLnF1YWxpdHkgPSBmdW5jdGlvbiBxdWFsaXR5KF9xdWFsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIHF1YWxpdHk6IF9xdWFsaXR5XG4gICAgICB9KTtcbiAgICB9IC8vIE1ha2UgaXQgYSBkb3dubG9hZCBsaW5rLiBQYXJhbWV0ZXIgaXMgZGVmYXVsdCBmaWxlbmFtZS5cbiAgICA7XG5cbiAgICBfcHJvdG8uZm9yY2VEb3dubG9hZCA9IGZ1bmN0aW9uIGZvcmNlRG93bmxvYWQoZG93bmxvYWQpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgZG93bmxvYWQ6IGRvd25sb2FkXG4gICAgICB9KTtcbiAgICB9IC8vIEZsaXAgaW1hZ2UgaG9yaXpvbnRhbGx5XG4gICAgO1xuXG4gICAgX3Byb3RvLmZsaXBIb3Jpem9udGFsID0gZnVuY3Rpb24gZmxpcEhvcml6b250YWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIGZsaXBIb3Jpem9udGFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IC8vIEZsaXAgaW1hZ2UgdmVydGljYWxseVxuICAgIDtcblxuICAgIF9wcm90by5mbGlwVmVydGljYWwgPSBmdW5jdGlvbiBmbGlwVmVydGljYWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIGZsaXBWZXJ0aWNhbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSAvLyBJZ25vcmUgY3JvcC9ob3RzcG90IGZyb20gaW1hZ2UgcmVjb3JkLCBldmVuIHdoZW4gcHJlc2VudFxuICAgIDtcblxuICAgIF9wcm90by5pZ25vcmVJbWFnZVBhcmFtcyA9IGZ1bmN0aW9uIGlnbm9yZUltYWdlUGFyYW1zKCkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aE9wdGlvbnMoe1xuICAgICAgICBpZ25vcmVJbWFnZVBhcmFtczogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5maXQgPSBmdW5jdGlvbiBmaXQodmFsdWUpIHtcbiAgICAgIGlmICh2YWxpZEZpdHMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZml0IG1vZGUgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgZml0OiB2YWx1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5jcm9wID0gZnVuY3Rpb24gY3JvcCh2YWx1ZSkge1xuICAgICAgaWYgKHZhbGlkQ3JvcHMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY3JvcCBtb2RlIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIGNyb3A6IHZhbHVlXG4gICAgICB9KTtcbiAgICB9IC8vIFNhdHVyYXRpb25cbiAgICA7XG5cbiAgICBfcHJvdG8uc2F0dXJhdGlvbiA9IGZ1bmN0aW9uIHNhdHVyYXRpb24oX3NhdHVyYXRpb24pIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgc2F0dXJhdGlvbjogX3NhdHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uYXV0byA9IGZ1bmN0aW9uIGF1dG8odmFsdWUpIHtcbiAgICAgIGlmICh2YWxpZEF1dG9Nb2Rlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhdXRvIG1vZGUgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLndpdGhPcHRpb25zKHtcbiAgICAgICAgYXV0bzogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0gLy8gU3BlY2lmeSB0aGUgbnVtYmVyIG9mIHBpeGVscyB0byBwYWQgdGhlIGltYWdlXG4gICAgO1xuXG4gICAgX3Byb3RvLnBhZCA9IGZ1bmN0aW9uIHBhZChfcGFkKSB7XG4gICAgICByZXR1cm4gdGhpcy53aXRoT3B0aW9ucyh7XG4gICAgICAgIHBhZDogX3BhZFxuICAgICAgfSk7XG4gICAgfSAvLyBHZXRzIHRoZSB1cmwgYmFzZWQgb24gdGhlIHN1Ym1pdHRlZCBwYXJhbWV0ZXJzXG4gICAgO1xuXG4gICAgX3Byb3RvLnVybCA9IGZ1bmN0aW9uIHVybCgpIHtcbiAgICAgIHJldHVybiB1cmxGb3JJbWFnZSh0aGlzLm9wdGlvbnMpO1xuICAgIH0gLy8gQWxpYXMgZm9yIHVybCgpXG4gICAgO1xuXG4gICAgX3Byb3RvLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy51cmwoKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEltYWdlVXJsQnVpbGRlcjtcbiAgfSgpO1xuXG4gIHJldHVybiB1cmxCdWlsZGVyO1xuXG59KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbWFnZS11cmwudW1kLmpzLm1hcFxuIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwic2VsZiIsIlNhbml0eUltYWdlVXJsQnVpbGRlciIsIl9leHRlbmRzIiwiT2JqZWN0IiwiYXNzaWduIiwidGFyZ2V0IiwiaSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsImtleSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImFwcGx5IiwiX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IiwibyIsIm1pbkxlbiIsIl9hcnJheUxpa2VUb0FycmF5IiwibiIsInRvU3RyaW5nIiwic2xpY2UiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJBcnJheSIsImZyb20iLCJ0ZXN0IiwiYXJyIiwibGVuIiwiYXJyMiIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UiLCJhbGxvd0FycmF5TGlrZSIsIml0IiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJuZXh0IiwiYmluZCIsImlzQXJyYXkiLCJkb25lIiwidmFsdWUiLCJUeXBlRXJyb3IiLCJleGFtcGxlIiwicGFyc2VBc3NldElkIiwicmVmIiwiX3JlZiRzcGxpdCIsInNwbGl0IiwiaWQiLCJkaW1lbnNpb25TdHJpbmciLCJmb3JtYXQiLCJFcnJvciIsIl9kaW1lbnNpb25TdHJpbmckc3BsaSIsImltZ1dpZHRoU3RyIiwiaW1nSGVpZ2h0U3RyIiwid2lkdGgiLCJoZWlnaHQiLCJpc1ZhbGlkQXNzZXRJZCIsImlzRmluaXRlIiwiaXNSZWYiLCJzcmMiLCJfcmVmIiwiaXNBc3NldCIsIl9pZCIsImlzQXNzZXRTdHViIiwiYXNzZXQiLCJ1cmwiLCJwYXJzZVNvdXJjZSIsImltYWdlIiwiaXNVcmwiLCJ1cmxUb0lkIiwiaW1nIiwiY3JvcCIsImhvdHNwb3QiLCJhcHBseURlZmF1bHRzIiwicGFydHMiLCJyZXBsYWNlIiwicmVzdWx0IiwibGVmdCIsInRvcCIsImJvdHRvbSIsInJpZ2h0IiwieCIsInkiLCJTUEVDX05BTUVfVE9fVVJMX05BTUVfTUFQUElOR1MiLCJ1cmxGb3JJbWFnZSIsIm9wdGlvbnMiLCJzcGVjIiwiSlNPTiIsInN0cmluZ2lmeSIsImNyb3BMZWZ0IiwiTWF0aCIsInJvdW5kIiwiY3JvcFRvcCIsImhvdFNwb3RWZXJ0aWNhbFJhZGl1cyIsImhvdFNwb3RIb3Jpem9udGFsUmFkaXVzIiwiaG90U3BvdENlbnRlclgiLCJob3RTcG90Q2VudGVyWSIsInJlY3QiLCJmb2NhbFBvaW50IiwiaWdub3JlSW1hZ2VQYXJhbXMiLCJmaXQiLCJzcGVjVG9JbWFnZVVybCIsImNkblVybCIsImJhc2VVcmwiLCJmaWxlbmFtZSIsInByb2plY3RJZCIsImRhdGFzZXQiLCJwYXJhbXMiLCJfc3BlYyRyZWN0IiwiaXNFZmZlY3RpdmVDcm9wIiwicHVzaCIsImJnIiwiZmxpcCIsImZsaXBIb3Jpem9udGFsIiwiZmxpcFZlcnRpY2FsIiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJmb3JFYWNoIiwibWFwcGluZyIsInNwZWNOYW1lIiwicGFyYW0iLCJlbmNvZGVVUklDb21wb25lbnQiLCJjcm9wUmVjdCIsImltZ1dpZHRoIiwiaW1nSGVpZ2h0IiwiZGVzaXJlZEFzcGVjdFJhdGlvIiwiY3JvcEFzcGVjdFJhdGlvIiwibWF4IiwiaG90c3BvdFhDZW50ZXIiLCJfd2lkdGgiLCJfaGVpZ2h0IiwiX2xlZnQiLCJob3RzcG90WUNlbnRlciIsIl90b3AiLCJ2YWxpZEZpdHMiLCJ2YWxpZENyb3BzIiwidmFsaWRBdXRvTW9kZXMiLCJpc1Nhbml0eU1vZGVybkNsaWVudExpa2UiLCJjbGllbnQiLCJjb25maWciLCJpc1Nhbml0eUNsaWVudExpa2UiLCJjbGllbnRDb25maWciLCJyZXdyaXRlU3BlY05hbWUiLCJzcGVjcyIsIl9pdGVyYXRvciIsIl9zdGVwIiwiZW50cnkiLCJ1cmxCdWlsZGVyIiwiX29wdGlvbnMkY29uZmlnIiwiYXBpVXJsIiwiYXBpSG9zdCIsIkltYWdlVXJsQnVpbGRlciIsIl9jbGllbnQkY2xpZW50Q29uZmlnIiwiX2FwaVVybCIsIl9wcm9qZWN0SWQiLCJfZGF0YXNldCIsIl9hcGlIb3N0IiwicGFyZW50IiwiX3Byb3RvIiwid2l0aE9wdGlvbnMiLCJuZXdPcHRpb25zIiwic3BlY0tleSIsIl9kYXRhc2V0MiIsIl9wcm9qZWN0SWQyIiwiX2JnIiwiZHByIiwiX2RwciIsIm1heFdpZHRoIiwiX21heFdpZHRoIiwibWluV2lkdGgiLCJfbWluV2lkdGgiLCJtYXhIZWlnaHQiLCJfbWF4SGVpZ2h0IiwibWluSGVpZ2h0IiwiX21pbkhlaWdodCIsInNpemUiLCJibHVyIiwiX2JsdXIiLCJzaGFycGVuIiwiX3NoYXJwZW4iLCJfZm9ybWF0IiwiaW52ZXJ0IiwiX2ludmVydCIsIm9yaWVudGF0aW9uIiwiX29yaWVudGF0aW9uIiwicXVhbGl0eSIsIl9xdWFsaXR5IiwiZm9yY2VEb3dubG9hZCIsImRvd25sb2FkIiwiaW5kZXhPZiIsInNhdHVyYXRpb24iLCJfc2F0dXJhdGlvbiIsImF1dG8iLCJwYWQiLCJfcGFkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/image-url/lib/browser/image-url.umd.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/eventsource/browser.js":
/*!*****************************************************!*\
  !*** ./node_modules/@sanity/eventsource/browser.js ***!
  \*****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\nmodule.exports = __webpack_require__(/*! event-source-polyfill */ \"(app-pages-browser)/./node_modules/event-source-polyfill/src/eventsource.js\").EventSourcePolyfill;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L2V2ZW50c291cmNlL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBQSxvS0FBcUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvZXZlbnRzb3VyY2UvYnJvd3Nlci5qcz85NmEzIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnQtc291cmNlLXBvbHlmaWxsJykuRXZlbnRTb3VyY2VQb2x5ZmlsbFxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiRXZlbnRTb3VyY2VQb2x5ZmlsbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/eventsource/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@sanity/preview-kit/dist/client/createClient.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@sanity/preview-kit/dist/client/createClient.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createClient: function() { return /* binding */ r; }\n/* harmony export */ });\n/* harmony import */ var _sanity_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @sanity/client */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/index.browser.js\");\n/* harmony import */ var _sanity_client_stega__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @sanity/client/stega */ \"(app-pages-browser)/./node_modules/@sanity/client/dist/stega.browser.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/process/browser.js\");\n\n\nconst r = (r)=>{\n    var a, c;\n    const { encodeSourceMap: i = n(), encodeSourceMapAtPath: l, studioUrl: u = o(), logger: s, ...p } = r;\n    let d = !0 === i;\n    if (\"auto\" === i && (d = function() {\n        try {\n            return \"preview\" === /* unsupported import.meta.env.VERCEL_ENV */ undefined.VERCEL_ENV;\n        } catch (e) {}\n        try {\n            return \"preview\" === process.env.VERCEL_ENV;\n        } catch (e) {}\n        return !1;\n    }()), \"string\" == typeof i && \"auto\" !== i) throw new Error(\"Invalid value for encodeSourceMap: \".concat(i, \". Did you mean 'auto'?\"));\n    try {\n        if (d && !1 !== r.resultSourceMap) return u ? (null == (c = null == s ? void 0 : s.debug) || c.call(s, \"[@sanity/preview-kit]: Creating source map enabled client\"), (0,_sanity_client_stega__WEBPACK_IMPORTED_MODULE_0__.createClient)({\n            ...p,\n            resultSourceMap: r.resultSourceMap ? r.resultSourceMap : \"withKeyArraySelector\",\n            stega: {\n                enabled: !0,\n                studioUrl: u,\n                logger: s,\n                filter: l ? (e)=>l({\n                        path: e.sourcePath,\n                        filterDefault: ()=>e.filterDefault(e)\n                    }) : void 0\n            }\n        })) : (null == (a = null == s ? void 0 : s.error) || a.call(s, \"[@sanity/preview-kit]: Content source map enabled client is enabled, but no studioUrl is provided. Falling back to @sanity/client\"), (0,_sanity_client__WEBPACK_IMPORTED_MODULE_1__.createClient)(p));\n    } catch (e) {\n        console.error(\"[@sanity/preview-kit]: Error creating client\", e, \"falling back to non-embedded sourcemap mode\");\n    }\n    return (0,_sanity_client__WEBPACK_IMPORTED_MODULE_1__.createClient)(p);\n};\nfunction n() {\n    try {\n        return \"true\" === /* unsupported import.meta.env.SANITY_SOURCE_MAP */ undefined.SANITY_SOURCE_MAP;\n    } catch (e) {}\n    try {\n        return \"true\" === process.env.SANITY_SOURCE_MAP;\n    } catch (e) {}\n    return !1;\n}\nfunction o() {\n    try {\n        return /* unsupported import.meta.env.SANITY_STUDIO_URL */ undefined.SANITY_STUDIO_URL;\n    } catch (e) {}\n    try {\n        return process.env.SANITY_STUDIO_URL;\n    } catch (e) {}\n}\n //# sourceMappingURL=createClient.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac2FuaXR5L3ByZXZpZXcta2l0L2Rpc3QvY2xpZW50L2NyZWF0ZUNsaWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQThDO0FBQW9EO0FBQUEsTUFBTUcsSUFBRUEsQ0FBQUE7SUFBSSxJQUFJQyxHQUFFQztJQUFFLE1BQUssRUFBQ0MsaUJBQWdCQyxJQUFFQyxHQUFHLEVBQUNDLHVCQUFzQkMsQ0FBQyxFQUFDQyxXQUFVQyxJQUFFQyxHQUFHLEVBQUNDLFFBQU9DLENBQUMsRUFBQyxHQUFHQyxHQUFFLEdBQUNiO0lBQUUsSUFBSWMsSUFBRSxDQUFDLE1BQUlWO0lBQUUsSUFBRyxXQUFTQSxLQUFJVSxDQUFBQSxJQUFFO1FBQVcsSUFBRztZQUFDLE9BQU0sY0FBWSxpRUFBMEI7UUFBQSxFQUFDLFVBQUssQ0FBQztRQUFDLElBQUc7WUFBQyxPQUFNLGNBQVlHLE9BQU9BLENBQUNGLEdBQUcsQ0FBQ0MsVUFBVTtRQUFBLEVBQUMsVUFBSyxDQUFDO1FBQUMsT0FBTSxDQUFDO0lBQUMsR0FBRSxHQUFHLFlBQVUsT0FBT1osS0FBRyxXQUFTQSxHQUFFLE1BQU0sSUFBSWMsTUFBTSxzQ0FBc0NDLE1BQU0sQ0FBQ2YsR0FBRTtJQUEyQixJQUFHO1FBQUMsSUFBR1UsS0FBRyxDQUFDLE1BQUlkLEVBQUVvQixlQUFlLEVBQUMsT0FBT1gsSUFBRyxTQUFPUCxDQUFBQSxJQUFFLFFBQU1VLElBQUUsS0FBSyxJQUFFQSxFQUFFUyxLQUFLLEtBQUduQixFQUFFb0IsSUFBSSxDQUFDVixHQUFFLDhEQUE2RGIsa0VBQUNBLENBQUM7WUFBQyxHQUFHYyxDQUFDO1lBQUNPLGlCQUFnQnBCLEVBQUVvQixlQUFlLEdBQUNwQixFQUFFb0IsZUFBZSxHQUFDO1lBQXVCRyxPQUFNO2dCQUFDQyxTQUFRLENBQUM7Z0JBQUVoQixXQUFVQztnQkFBRUUsUUFBT0M7Z0JBQUVhLFFBQU9sQixJQUFFVCxDQUFBQSxJQUFHUyxFQUFFO3dCQUFDbUIsTUFBSzVCLEVBQUU2QixVQUFVO3dCQUFDQyxlQUFjLElBQUk5QixFQUFFOEIsYUFBYSxDQUFDOUI7b0JBQUUsS0FBRyxLQUFLO1lBQUM7UUFBQyxFQUFDLElBQUksU0FBT0csQ0FBQUEsSUFBRSxRQUFNVyxJQUFFLEtBQUssSUFBRUEsRUFBRWlCLEtBQUssS0FBRzVCLEVBQUVxQixJQUFJLENBQUNWLEdBQUUsc0lBQXFJZCw0REFBQ0EsQ0FBQ2UsRUFBQztJQUFFLEVBQUMsT0FBTWYsR0FBRTtRQUFDZ0MsUUFBUUQsS0FBSyxDQUFDLGdEQUErQy9CLEdBQUU7SUFBOEM7SUFBQyxPQUFPQSw0REFBQ0EsQ0FBQ2U7QUFBRTtBQUFFLFNBQVNSO0lBQUksSUFBRztRQUFDLE9BQU0sV0FBUywrRUFBaUM7SUFBQSxFQUFDLFVBQUssQ0FBQztJQUFDLElBQUc7UUFBQyxPQUFNLFdBQVNZLE9BQU9BLENBQUNGLEdBQUcsQ0FBQ2dCLGlCQUFpQjtJQUFBLEVBQUMsVUFBSyxDQUFDO0lBQUMsT0FBTSxDQUFDO0FBQUM7QUFBQyxTQUFTckI7SUFBSSxJQUFHO1FBQUMsT0FBTywrRUFBaUM7SUFBQSxFQUFDLFVBQUssQ0FBQztJQUFDLElBQUc7UUFBQyxPQUFPTyxPQUFPQSxDQUFDRixHQUFHLENBQUNpQixpQkFBaUI7SUFBQSxFQUFDLFVBQUssQ0FBQztBQUFDO0FBQTJCLENBQ3g1Qyx3Q0FBd0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzYW5pdHkvcHJldmlldy1raXQvZGlzdC9jbGllbnQvY3JlYXRlQ2xpZW50LmpzPzNiYjkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e2NyZWF0ZUNsaWVudCBhcyBlfWZyb21cIkBzYW5pdHkvY2xpZW50XCI7aW1wb3J0e2NyZWF0ZUNsaWVudCBhcyB0fWZyb21cIkBzYW5pdHkvY2xpZW50L3N0ZWdhXCI7Y29uc3Qgcj1yPT57dmFyIGEsYztjb25zdHtlbmNvZGVTb3VyY2VNYXA6aT1uKCksZW5jb2RlU291cmNlTWFwQXRQYXRoOmwsc3R1ZGlvVXJsOnU9bygpLGxvZ2dlcjpzLC4uLnB9PXI7bGV0IGQ9ITA9PT1pO2lmKFwiYXV0b1wiPT09aSYmKGQ9ZnVuY3Rpb24oKXt0cnl7cmV0dXJuXCJwcmV2aWV3XCI9PT1pbXBvcnQubWV0YS5lbnYuVkVSQ0VMX0VOVn1jYXRjaHt9dHJ5e3JldHVyblwicHJldmlld1wiPT09cHJvY2Vzcy5lbnYuVkVSQ0VMX0VOVn1jYXRjaHt9cmV0dXJuITF9KCkpLFwic3RyaW5nXCI9PXR5cGVvZiBpJiZcImF1dG9cIiE9PWkpdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB2YWx1ZSBmb3IgZW5jb2RlU291cmNlTWFwOiBcIi5jb25jYXQoaSxcIi4gRGlkIHlvdSBtZWFuICdhdXRvJz9cIikpO3RyeXtpZihkJiYhMSE9PXIucmVzdWx0U291cmNlTWFwKXJldHVybiB1PyhudWxsPT0oYz1udWxsPT1zP3ZvaWQgMDpzLmRlYnVnKXx8Yy5jYWxsKHMsXCJbQHNhbml0eS9wcmV2aWV3LWtpdF06IENyZWF0aW5nIHNvdXJjZSBtYXAgZW5hYmxlZCBjbGllbnRcIiksdCh7Li4ucCxyZXN1bHRTb3VyY2VNYXA6ci5yZXN1bHRTb3VyY2VNYXA/ci5yZXN1bHRTb3VyY2VNYXA6XCJ3aXRoS2V5QXJyYXlTZWxlY3RvclwiLHN0ZWdhOntlbmFibGVkOiEwLHN0dWRpb1VybDp1LGxvZ2dlcjpzLGZpbHRlcjpsP2U9Pmwoe3BhdGg6ZS5zb3VyY2VQYXRoLGZpbHRlckRlZmF1bHQ6KCk9PmUuZmlsdGVyRGVmYXVsdChlKX0pOnZvaWQgMH19KSk6KG51bGw9PShhPW51bGw9PXM/dm9pZCAwOnMuZXJyb3IpfHxhLmNhbGwocyxcIltAc2FuaXR5L3ByZXZpZXcta2l0XTogQ29udGVudCBzb3VyY2UgbWFwIGVuYWJsZWQgY2xpZW50IGlzIGVuYWJsZWQsIGJ1dCBubyBzdHVkaW9VcmwgaXMgcHJvdmlkZWQuIEZhbGxpbmcgYmFjayB0byBAc2FuaXR5L2NsaWVudFwiKSxlKHApKX1jYXRjaChlKXtjb25zb2xlLmVycm9yKFwiW0BzYW5pdHkvcHJldmlldy1raXRdOiBFcnJvciBjcmVhdGluZyBjbGllbnRcIixlLFwiZmFsbGluZyBiYWNrIHRvIG5vbi1lbWJlZGRlZCBzb3VyY2VtYXAgbW9kZVwiKX1yZXR1cm4gZShwKX07ZnVuY3Rpb24gbigpe3RyeXtyZXR1cm5cInRydWVcIj09PWltcG9ydC5tZXRhLmVudi5TQU5JVFlfU09VUkNFX01BUH1jYXRjaHt9dHJ5e3JldHVyblwidHJ1ZVwiPT09cHJvY2Vzcy5lbnYuU0FOSVRZX1NPVVJDRV9NQVB9Y2F0Y2h7fXJldHVybiExfWZ1bmN0aW9uIG8oKXt0cnl7cmV0dXJuIGltcG9ydC5tZXRhLmVudi5TQU5JVFlfU1RVRElPX1VSTH1jYXRjaHt9dHJ5e3JldHVybiBwcm9jZXNzLmVudi5TQU5JVFlfU1RVRElPX1VSTH1jYXRjaHt9fWV4cG9ydHtyIGFzIGNyZWF0ZUNsaWVudH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcmVhdGVDbGllbnQuanMubWFwXG4iXSwibmFtZXMiOlsiY3JlYXRlQ2xpZW50IiwiZSIsInQiLCJyIiwiYSIsImMiLCJlbmNvZGVTb3VyY2VNYXAiLCJpIiwibiIsImVuY29kZVNvdXJjZU1hcEF0UGF0aCIsImwiLCJzdHVkaW9VcmwiLCJ1IiwibyIsImxvZ2dlciIsInMiLCJwIiwiZCIsImVudiIsIlZFUkNFTF9FTlYiLCJwcm9jZXNzIiwiRXJyb3IiLCJjb25jYXQiLCJyZXN1bHRTb3VyY2VNYXAiLCJkZWJ1ZyIsImNhbGwiLCJzdGVnYSIsImVuYWJsZWQiLCJmaWx0ZXIiLCJwYXRoIiwic291cmNlUGF0aCIsImZpbHRlckRlZmF1bHQiLCJlcnJvciIsImNvbnNvbGUiLCJTQU5JVFlfU09VUkNFX01BUCIsIlNBTklUWV9TVFVESU9fVVJMIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@sanity/preview-kit/dist/client/createClient.js\n"));

/***/ })

}]);