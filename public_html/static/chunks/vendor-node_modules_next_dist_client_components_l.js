"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendor-node_modules_next_dist_client_components_l"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/layout-router.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return OuterLayoutRouter;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _reactdom = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\"));\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _fetchserverresponse = __webpack_require__(/*! ./router-reducer/fetch-server-response */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/fetch-server-response.js\");\nconst _infinitepromise = __webpack_require__(/*! ./infinite-promise */ \"(app-pages-browser)/./node_modules/next/dist/client/components/infinite-promise.js\");\nconst _errorboundary = __webpack_require__(/*! ./error-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/error-boundary.js\");\nconst _matchsegments = __webpack_require__(/*! ./match-segments */ \"(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\");\nconst _handlesmoothscroll = __webpack_require__(/*! ../../shared/lib/router/utils/handle-smooth-scroll */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nconst _redirectboundary = __webpack_require__(/*! ./redirect-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect-boundary.js\");\nconst _notfoundboundary = __webpack_require__(/*! ./not-found-boundary */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _createroutercachekey = __webpack_require__(/*! ./router-reducer/create-router-cache-key */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/create-router-cache-key.js\");\n/**\n * Add refetch marker to router state at the point of the current layout segment.\n * This ensures the response returned is not further down than the current layout segment.\n */ function walkAddRefetch(segmentPathToWalk, treeToRecreate) {\n    if (segmentPathToWalk) {\n        const [segment, parallelRouteKey] = segmentPathToWalk;\n        const isLast = segmentPathToWalk.length === 2;\n        if ((0, _matchsegments.matchSegment)(treeToRecreate[0], segment)) {\n            if (treeToRecreate[1].hasOwnProperty(parallelRouteKey)) {\n                if (isLast) {\n                    const subTree = walkAddRefetch(undefined, treeToRecreate[1][parallelRouteKey]);\n                    return [\n                        treeToRecreate[0],\n                        {\n                            ...treeToRecreate[1],\n                            [parallelRouteKey]: [\n                                subTree[0],\n                                subTree[1],\n                                subTree[2],\n                                \"refetch\"\n                            ]\n                        }\n                    ];\n                }\n                return [\n                    treeToRecreate[0],\n                    {\n                        ...treeToRecreate[1],\n                        [parallelRouteKey]: walkAddRefetch(segmentPathToWalk.slice(2), treeToRecreate[1][parallelRouteKey])\n                    }\n                ];\n            }\n        }\n    }\n    return treeToRecreate;\n}\n// TODO-APP: Replace with new React API for finding dom nodes without a `ref` when available\n/**\n * Wraps ReactDOM.findDOMNode with additional logic to hide React Strict Mode warning\n */ function findDOMNode(instance) {\n    // Tree-shake for server bundle\n    if (false) {}\n    // Only apply strict mode warning when not in production\n    if (true) {\n        const originalConsoleError = console.error;\n        try {\n            console.error = function() {\n                for(var _len = arguments.length, messages = new Array(_len), _key = 0; _key < _len; _key++){\n                    messages[_key] = arguments[_key];\n                }\n                // Ignore strict mode warning for the findDomNode call below\n                if (!messages[0].includes(\"Warning: %s is deprecated in StrictMode.\")) {\n                    originalConsoleError(...messages);\n                }\n            };\n            return _reactdom.default.findDOMNode(instance);\n        } finally{\n            console.error = originalConsoleError;\n        }\n    }\n    return _reactdom.default.findDOMNode(instance);\n}\nconst rectProperties = [\n    \"bottom\",\n    \"height\",\n    \"left\",\n    \"right\",\n    \"top\",\n    \"width\",\n    \"x\",\n    \"y\"\n];\n/**\n * Check if a HTMLElement is hidden or fixed/sticky position\n */ function shouldSkipElement(element) {\n    // we ignore fixed or sticky positioned elements since they'll likely pass the \"in-viewport\" check\n    // and will result in a situation we bail on scroll because of something like a fixed nav,\n    // even though the actual page content is offscreen\n    if ([\n        \"sticky\",\n        \"fixed\"\n    ].includes(getComputedStyle(element).position)) {\n        if (true) {\n            console.warn(\"Skipping auto-scroll behavior due to `position: sticky` or `position: fixed` on element:\", element);\n        }\n        return true;\n    }\n    // Uses `getBoundingClientRect` to check if the element is hidden instead of `offsetParent`\n    // because `offsetParent` doesn't consider document/body\n    const rect = element.getBoundingClientRect();\n    return rectProperties.every((item)=>rect[item] === 0);\n}\n/**\n * Check if the top corner of the HTMLElement is in the viewport.\n */ function topOfElementInViewport(element, viewportHeight) {\n    const rect = element.getBoundingClientRect();\n    return rect.top >= 0 && rect.top <= viewportHeight;\n}\n/**\n * Find the DOM node for a hash fragment.\n * If `top` the page has to scroll to the top of the page. This mirrors the browser's behavior.\n * If the hash fragment is an id, the page has to scroll to the element with that id.\n * If the hash fragment is a name, the page has to scroll to the first element with that name.\n */ function getHashFragmentDomNode(hashFragment) {\n    // If the hash fragment is `top` the page has to scroll to the top of the page.\n    if (hashFragment === \"top\") {\n        return document.body;\n    }\n    var _document_getElementById;\n    // If the hash fragment is an id, the page has to scroll to the element with that id.\n    return (_document_getElementById = document.getElementById(hashFragment)) != null ? _document_getElementById : document.getElementsByName(hashFragment)[0];\n}\nclass InnerScrollAndFocusHandler extends _react.default.Component {\n    componentDidMount() {\n        this.handlePotentialScroll();\n    }\n    componentDidUpdate() {\n        // Because this property is overwritten in handlePotentialScroll it's fine to always run it when true as it'll be set to false for subsequent renders.\n        if (this.props.focusAndScrollRef.apply) {\n            this.handlePotentialScroll();\n        }\n    }\n    render() {\n        return this.props.children;\n    }\n    constructor(...args){\n        super(...args);\n        this.handlePotentialScroll = ()=>{\n            // Handle scroll and focus, it's only applied once in the first useEffect that triggers that changed.\n            const { focusAndScrollRef, segmentPath } = this.props;\n            if (focusAndScrollRef.apply) {\n                // segmentPaths is an array of segment paths that should be scrolled to\n                // if the current segment path is not in the array, the scroll is not applied\n                // unless the array is empty, in which case the scroll is always applied\n                if (focusAndScrollRef.segmentPaths.length !== 0 && !focusAndScrollRef.segmentPaths.some((scrollRefSegmentPath)=>segmentPath.every((segment, index)=>(0, _matchsegments.matchSegment)(segment, scrollRefSegmentPath[index])))) {\n                    return;\n                }\n                let domNode = null;\n                const hashFragment = focusAndScrollRef.hashFragment;\n                if (hashFragment) {\n                    domNode = getHashFragmentDomNode(hashFragment);\n                }\n                // `findDOMNode` is tricky because it returns just the first child if the component is a fragment.\n                // This already caused a bug where the first child was a <link/> in head.\n                if (!domNode) {\n                    domNode = findDOMNode(this);\n                }\n                // If there is no DOM node this layout-router level is skipped. It'll be handled higher-up in the tree.\n                if (!(domNode instanceof Element)) {\n                    return;\n                }\n                // Verify if the element is a HTMLElement and if we want to consider it for scroll behavior.\n                // If the element is skipped, try to select the next sibling and try again.\n                while(!(domNode instanceof HTMLElement) || shouldSkipElement(domNode)){\n                    // No siblings found that match the criteria are found, so handle scroll higher up in the tree instead.\n                    if (domNode.nextElementSibling === null) {\n                        return;\n                    }\n                    domNode = domNode.nextElementSibling;\n                }\n                // State is mutated to ensure that the focus and scroll is applied only once.\n                focusAndScrollRef.apply = false;\n                focusAndScrollRef.hashFragment = null;\n                focusAndScrollRef.segmentPaths = [];\n                (0, _handlesmoothscroll.handleSmoothScroll)(()=>{\n                    // In case of hash scroll, we only need to scroll the element into view\n                    if (hashFragment) {\n                        domNode.scrollIntoView();\n                        return;\n                    }\n                    // Store the current viewport height because reading `clientHeight` causes a reflow,\n                    // and it won't change during this function.\n                    const htmlElement = document.documentElement;\n                    const viewportHeight = htmlElement.clientHeight;\n                    // If the element's top edge is already in the viewport, exit early.\n                    if (topOfElementInViewport(domNode, viewportHeight)) {\n                        return;\n                    }\n                    // Otherwise, try scrolling go the top of the document to be backward compatible with pages\n                    // scrollIntoView() called on `<html/>` element scrolls horizontally on chrome and firefox (that shouldn't happen)\n                    // We could use it to scroll horizontally following RTL but that also seems to be broken - it will always scroll left\n                    // scrollLeft = 0 also seems to ignore RTL and manually checking for RTL is too much hassle so we will scroll just vertically\n                    htmlElement.scrollTop = 0;\n                    // Scroll to domNode if domNode is not in viewport when scrolled to top of document\n                    if (!topOfElementInViewport(domNode, viewportHeight)) {\n                        domNode.scrollIntoView();\n                    }\n                }, {\n                    // We will force layout by querying domNode position\n                    dontForceLayout: true,\n                    onlyHashChange: focusAndScrollRef.onlyHashChange\n                });\n                // Mutate after scrolling so that it can be read by `handleSmoothScroll`\n                focusAndScrollRef.onlyHashChange = false;\n                // Set focus on the element\n                domNode.focus();\n            }\n        };\n    }\n}\nfunction ScrollAndFocusHandler(param) {\n    let { segmentPath, children } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerScrollAndFocusHandler, {\n        segmentPath: segmentPath,\n        focusAndScrollRef: context.focusAndScrollRef,\n        children: children\n    });\n}\n_c = ScrollAndFocusHandler;\n/**\n * InnerLayoutRouter handles rendering the provided segment based on the cache.\n */ function InnerLayoutRouter(param) {\n    let { parallelRouterKey, url, childNodes, segmentPath, tree, // isActive,\n    cacheKey } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant global layout router not mounted\");\n    }\n    const { buildId, changeByServerResponse, tree: fullTree } = context;\n    // Read segment path from the parallel router cache node.\n    let childNode = childNodes.get(cacheKey);\n    // When data is not available during rendering client-side we need to fetch\n    // it from the server.\n    if (childNode === undefined) {\n        const newLazyCacheNode = {\n            lazyData: null,\n            rsc: null,\n            prefetchRsc: null,\n            head: null,\n            parallelRoutes: new Map()\n        };\n        /**\n     * Flight data fetch kicked off during render and put into the cache.\n     */ childNode = newLazyCacheNode;\n        childNodes.set(cacheKey, newLazyCacheNode);\n    }\n    // `rsc` represents the renderable node for this segment.\n    // If this segment has a `prefetchRsc`, it's the statically prefetched data.\n    // We should use that on initial render instead of `rsc`. Then we'll switch\n    // to `rsc` when the dynamic response streams in.\n    //\n    // If no prefetch data is available, then we go straight to rendering `rsc`.\n    const resolvedPrefetchRsc = childNode.prefetchRsc !== null ? childNode.prefetchRsc : childNode.rsc;\n    // We use `useDeferredValue` to handle switching between the prefetched and\n    // final values. The second argument is returned on initial render, then it\n    // re-renders with the first argument.\n    //\n    // @ts-expect-error The second argument to `useDeferredValue` is only\n    // available in the experimental builds. When its disabled, it will always\n    // return `rsc`.\n    const rsc = (0, _react.useDeferredValue)(childNode.rsc, resolvedPrefetchRsc);\n    // `rsc` is either a React node or a promise for a React node, except we\n    // special case `null` to represent that this segment's data is missing. If\n    // it's a promise, we need to unwrap it so we can determine whether or not the\n    // data is missing.\n    const resolvedRsc = typeof rsc === \"object\" && rsc !== null && typeof rsc.then === \"function\" ? (0, _react.use)(rsc) : rsc;\n    if (!resolvedRsc) {\n        // The data for this segment is not available, and there's no pending\n        // navigation that will be able to fulfill it. We need to fetch more from\n        // the server and patch the cache.\n        // Check if there's already a pending request.\n        let lazyData = childNode.lazyData;\n        if (lazyData === null) {\n            /**\n       * Router state with refetch marker added\n       */ // TODO-APP: remove ''\n            const refetchTree = walkAddRefetch([\n                \"\",\n                ...segmentPath\n            ], fullTree);\n            childNode.lazyData = lazyData = (0, _fetchserverresponse.fetchServerResponse)(new URL(url, location.origin), refetchTree, context.nextUrl, buildId);\n        }\n        /**\n     * Flight response data\n     */ // When the data has not resolved yet `use` will suspend here.\n        const [flightData, overrideCanonicalUrl] = (0, _react.use)(lazyData);\n        // segmentPath from the server does not match the layout's segmentPath\n        childNode.lazyData = null;\n        // setTimeout is used to start a new transition during render, this is an intentional hack around React.\n        setTimeout(()=>{\n            (0, _react.startTransition)(()=>{\n                changeByServerResponse(fullTree, flightData, overrideCanonicalUrl);\n            });\n        });\n        // Suspend infinitely as `changeByServerResponse` will cause a different part of the tree to be rendered.\n        (0, _react.use)((0, _infinitepromise.createInfinitePromise)());\n    }\n    // If we get to this point, then we know we have something we can render.\n    const subtree = /*#__PURE__*/ (0, _jsxruntime.jsx)(_approutercontextsharedruntime.LayoutRouterContext.Provider, {\n        value: {\n            tree: tree[1][parallelRouterKey],\n            childNodes: childNode.parallelRoutes,\n            // TODO-APP: overriding of url for parallel routes\n            url: url\n        },\n        children: resolvedRsc\n    });\n    // Ensure root layout is not wrapped in a div as the root layout renders `<html>`\n    return subtree;\n}\n_c1 = InnerLayoutRouter;\n/**\n * Renders suspense boundary with the provided \"loading\" property as the fallback.\n * If no loading property is provided it renders the children without a suspense boundary.\n */ function LoadingBoundary(param) {\n    let { children, loading, loadingStyles, loadingScripts, hasLoading } = param;\n    if (hasLoading) {\n        return /*#__PURE__*/ (0, _jsxruntime.jsx)(_react.Suspense, {\n            fallback: /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    loadingStyles,\n                    loadingScripts,\n                    loading\n                ]\n            }),\n            children: children\n        });\n    }\n    return /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c2 = LoadingBoundary;\nfunction OuterLayoutRouter(param) {\n    let { parallelRouterKey, segmentPath, error, errorStyles, errorScripts, templateStyles, templateScripts, loading, loadingStyles, loadingScripts, hasLoading, template, notFound, notFoundStyles, styles } = param;\n    const context = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    if (!context) {\n        throw new Error(\"invariant expected layout router to be mounted\");\n    }\n    const { childNodes, tree, url } = context;\n    // Get the current parallelRouter cache node\n    let childNodesForParallelRouter = childNodes.get(parallelRouterKey);\n    // If the parallel router cache node does not exist yet, create it.\n    // This writes to the cache when there is no item in the cache yet. It never *overwrites* existing cache items which is why it's safe in concurrent mode.\n    if (!childNodesForParallelRouter) {\n        childNodesForParallelRouter = new Map();\n        childNodes.set(parallelRouterKey, childNodesForParallelRouter);\n    }\n    // Get the active segment in the tree\n    // The reason arrays are used in the data format is that these are transferred from the server to the browser so it's optimized to save bytes.\n    const treeSegment = tree[1][parallelRouterKey][0];\n    // If segment is an array it's a dynamic route and we want to read the dynamic route value as the segment to get from the cache.\n    const currentChildSegmentValue = (0, _getsegmentvalue.getSegmentValue)(treeSegment);\n    /**\n   * Decides which segments to keep rendering, all segments that are not active will be wrapped in `<Offscreen>`.\n   */ // TODO-APP: Add handling of `<Offscreen>` when it's available.\n    const preservedSegments = [\n        treeSegment\n    ];\n    return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n        children: [\n            styles,\n            preservedSegments.map((preservedSegment)=>{\n                const preservedSegmentValue = (0, _getsegmentvalue.getSegmentValue)(preservedSegment);\n                const cacheKey = (0, _createroutercachekey.createRouterCacheKey)(preservedSegment);\n                return(/*\n            - Error boundary\n              - Only renders error boundary if error component is provided.\n              - Rendered for each segment to ensure they have their own error state.\n            - Loading boundary\n              - Only renders suspense boundary if loading components is provided.\n              - Rendered for each segment to ensure they have their own loading state.\n              - Passed to the router during rendering to ensure it can be immediately rendered when suspending on a Flight fetch.\n          */ /*#__PURE__*/ (0, _jsxruntime.jsxs)(_approutercontextsharedruntime.TemplateContext.Provider, {\n                    value: /*#__PURE__*/ (0, _jsxruntime.jsx)(ScrollAndFocusHandler, {\n                        segmentPath: segmentPath,\n                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_errorboundary.ErrorBoundary, {\n                            errorComponent: error,\n                            errorStyles: errorStyles,\n                            errorScripts: errorScripts,\n                            children: /*#__PURE__*/ (0, _jsxruntime.jsx)(LoadingBoundary, {\n                                hasLoading: hasLoading,\n                                loading: loading,\n                                loadingStyles: loadingStyles,\n                                loadingScripts: loadingScripts,\n                                children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_notfoundboundary.NotFoundBoundary, {\n                                    notFound: notFound,\n                                    notFoundStyles: notFoundStyles,\n                                    children: /*#__PURE__*/ (0, _jsxruntime.jsx)(_redirectboundary.RedirectBoundary, {\n                                        children: /*#__PURE__*/ (0, _jsxruntime.jsx)(InnerLayoutRouter, {\n                                            parallelRouterKey: parallelRouterKey,\n                                            url: url,\n                                            tree: tree,\n                                            childNodes: childNodesForParallelRouter,\n                                            segmentPath: segmentPath,\n                                            cacheKey: cacheKey,\n                                            isActive: currentChildSegmentValue === preservedSegmentValue\n                                        })\n                                    })\n                                })\n                            })\n                        })\n                    }),\n                    children: [\n                        templateStyles,\n                        templateScripts,\n                        template\n                    ]\n                }, (0, _createroutercachekey.createRouterCacheKey)(preservedSegment, true)));\n            })\n        ]\n    });\n}\n_c3 = OuterLayoutRouter;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=layout-router.js.map\nvar _c, _c1, _c2, _c3;\n$RefreshReg$(_c, \"ScrollAndFocusHandler\");\n$RefreshReg$(_c1, \"InnerLayoutRouter\");\n$RefreshReg$(_c2, \"LoadingBoundary\");\n$RefreshReg$(_c3, \"OuterLayoutRouter\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcyIsIm1hcHBpbmdzIjoicURBRWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUdlO0lBQ1hJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQywyQkFBMkJDLG1CQUFPQSxDQUFDLGdJQUF5QztBQUNsRixNQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLGtJQUEwQztBQUNwRixNQUFNRSxjQUFjRixtQkFBT0EsQ0FBQyxxR0FBbUI7QUFDL0MsTUFBTUcsU0FBUyxXQUFXLEdBQUdGLDBCQUEwQkcsQ0FBQyxDQUFDSixtQkFBT0EsQ0FBQyxtRkFBTztBQUN4RSxNQUFNSyxZQUFZLFdBQVcsR0FBR04seUJBQXlCSyxDQUFDLENBQUNKLG1CQUFPQSxDQUFDLDJGQUFXO0FBQzlFLE1BQU1NLGlDQUFpQ04sbUJBQU9BLENBQUMsd0pBQW9EO0FBQ25HLE1BQU1PLHVCQUF1QlAsbUJBQU9BLENBQUMsc0pBQXdDO0FBQzdFLE1BQU1RLG1CQUFtQlIsbUJBQU9BLENBQUMsOEdBQW9CO0FBQ3JELE1BQU1TLGlCQUFpQlQsbUJBQU9BLENBQUMsMEdBQWtCO0FBQ2pELE1BQU1VLGlCQUFpQlYsbUJBQU9BLENBQUMsMEdBQWtCO0FBQ2pELE1BQU1XLHNCQUFzQlgsbUJBQU9BLENBQUMsd0pBQW9EO0FBQ3hGLE1BQU1ZLG9CQUFvQlosbUJBQU9BLENBQUMsZ0hBQXFCO0FBQ3ZELE1BQU1hLG9CQUFvQmIsbUJBQU9BLENBQUMsa0hBQXNCO0FBQ3hELE1BQU1jLG1CQUFtQmQsbUJBQU9BLENBQUMsZ0tBQTZDO0FBQzlFLE1BQU1lLHdCQUF3QmYsbUJBQU9BLENBQUMsMEpBQTBDO0FBQ2hGOzs7Q0FHQyxHQUFHLFNBQVNnQixlQUFlQyxpQkFBaUIsRUFB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QUFZbUQ7NENBQ1ovRSxhQUFhQTs0Q0FDYjhCLFVBQVVBOzRDQUNWK0QsVUFBVVosNkJBQTZCSzt3Q0FDM0M7b0NBQ0o7Z0NBQ0o7NEJBQ0o7d0JBQ0o7b0JBQ0o7b0JBQ0F6RixVQUFVO3dCQUNONEU7d0JBQ0FDO3dCQUNBQztxQkFDSDtnQkFDTCxHQUFHLENBQUMsR0FBR3JJLHNCQUFzQmlKLG9CQUFvQixFQUFFRixrQkFBa0I7WUFDekU7U0FDSDtJQUNMO0FBQ0o7TUEvRVNoSztBQWlGVCxJQUFJLENBQUMsT0FBT0osUUFBUThDLE9BQU8sS0FBSyxjQUFlLE9BQU85QyxRQUFROEMsT0FBTyxLQUFLLFlBQVk5QyxRQUFROEMsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPOUMsUUFBUThDLE9BQU8sQ0FBQytILFVBQVUsS0FBSyxhQUFhO0lBQ3JLL0ssT0FBT0MsY0FBYyxDQUFDQyxRQUFROEMsT0FBTyxFQUFFLGNBQWM7UUFBRTdDLE9BQU87SUFBSztJQUNuRUgsT0FBT2dMLE1BQU0sQ0FBQzlLLFFBQVE4QyxPQUFPLEVBQUU5QztJQUMvQitLLE9BQU8vSyxPQUFPLEdBQUdBLFFBQVE4QyxPQUFPO0FBQ2xDLEVBRUEseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbGF5b3V0LXJvdXRlci5qcz8wYmZhIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXG5cInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAvKipcbiAqIE91dGVyTGF5b3V0Um91dGVyIGhhbmRsZXMgdGhlIGN1cnJlbnQgc2VnbWVudCBhcyB3ZWxsIGFzIDxPZmZzY3JlZW4+IHJlbmRlcmluZyBvZiBvdGhlciBzZWdtZW50cy5cbiAqIEl0IGNhbiBiZSByZW5kZXJlZCBuZXh0IHRvIGVhY2ggb3RoZXIgd2l0aCBhIGRpZmZlcmVudCBgcGFyYWxsZWxSb3V0ZXJLZXlgLCBhbGxvd2luZyBmb3IgUGFyYWxsZWwgcm91dGVzLlxuICovIFwiZGVmYXVsdFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gT3V0ZXJMYXlvdXRSb3V0ZXI7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX2pzeHJ1bnRpbWUgPSByZXF1aXJlKFwicmVhY3QvanN4LXJ1bnRpbWVcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQuXyhyZXF1aXJlKFwicmVhY3RcIikpO1xuY29uc3QgX3JlYWN0ZG9tID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQuXyhyZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9mZXRjaHNlcnZlcnJlc3BvbnNlID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvZmV0Y2gtc2VydmVyLXJlc3BvbnNlXCIpO1xuY29uc3QgX2luZmluaXRlcHJvbWlzZSA9IHJlcXVpcmUoXCIuL2luZmluaXRlLXByb21pc2VcIik7XG5jb25zdCBfZXJyb3Jib3VuZGFyeSA9IHJlcXVpcmUoXCIuL2Vycm9yLWJvdW5kYXJ5XCIpO1xuY29uc3QgX21hdGNoc2VnbWVudHMgPSByZXF1aXJlKFwiLi9tYXRjaC1zZWdtZW50c1wiKTtcbmNvbnN0IF9oYW5kbGVzbW9vdGhzY3JvbGwgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaGFuZGxlLXNtb290aC1zY3JvbGxcIik7XG5jb25zdCBfcmVkaXJlY3Rib3VuZGFyeSA9IHJlcXVpcmUoXCIuL3JlZGlyZWN0LWJvdW5kYXJ5XCIpO1xuY29uc3QgX25vdGZvdW5kYm91bmRhcnkgPSByZXF1aXJlKFwiLi9ub3QtZm91bmQtYm91bmRhcnlcIik7XG5jb25zdCBfZ2V0c2VnbWVudHZhbHVlID0gcmVxdWlyZShcIi4vcm91dGVyLXJlZHVjZXIvcmVkdWNlcnMvZ2V0LXNlZ21lbnQtdmFsdWVcIik7XG5jb25zdCBfY3JlYXRlcm91dGVyY2FjaGVrZXkgPSByZXF1aXJlKFwiLi9yb3V0ZXItcmVkdWNlci9jcmVhdGUtcm91dGVyLWNhY2hlLWtleVwiKTtcbi8qKlxuICogQWRkIHJlZmV0Y2ggbWFya2VyIHRvIHJvdXRlciBzdGF0ZSBhdCB0aGUgcG9pbnQgb2YgdGhlIGN1cnJlbnQgbGF5b3V0IHNlZ21lbnQuXG4gKiBUaGlzIGVuc3VyZXMgdGhlIHJlc3BvbnNlIHJldHVybmVkIGlzIG5vdCBmdXJ0aGVyIGRvd24gdGhhbiB0aGUgY3VycmVudCBsYXlvdXQgc2VnbWVudC5cbiAqLyBmdW5jdGlvbiB3YWxrQWRkUmVmZXRjaChzZWdtZW50UGF0aFRvV2FsaywgdHJlZVRvUmVjcmVhdGUpIHtcbiAgICBpZiAoc2VnbWVudFBhdGhUb1dhbGspIHtcbiAgICAgICAgY29uc3QgW3NlZ21lbnQsIHBhcmFsbGVsUm91dGVLZXldID0gc2VnbWVudFBhdGhUb1dhbGs7XG4gICAgICAgIGNvbnN0IGlzTGFzdCA9IHNlZ21lbnRQYXRoVG9XYWxrLmxlbmd0aCA9PT0gMjtcbiAgICAgICAgaWYgKCgwLCBfbWF0Y2hzZWdtZW50cy5tYXRjaFNlZ21lbnQpKHRyZWVUb1JlY3JlYXRlWzBdLCBzZWdtZW50KSkge1xuICAgICAgICAgICAgaWYgKHRyZWVUb1JlY3JlYXRlWzFdLmhhc093blByb3BlcnR5KHBhcmFsbGVsUm91dGVLZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdWJUcmVlID0gd2Fsa0FkZFJlZmV0Y2godW5kZWZpbmVkLCB0cmVlVG9SZWNyZWF0ZVsxXVtwYXJhbGxlbFJvdXRlS2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmVlVG9SZWNyZWF0ZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbcGFyYWxsZWxSb3V0ZUtleV06IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViVHJlZVsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJyZWZldGNoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHRyZWVUb1JlY3JlYXRlWzBdLFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi50cmVlVG9SZWNyZWF0ZVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtwYXJhbGxlbFJvdXRlS2V5XTogd2Fsa0FkZFJlZmV0Y2goc2VnbWVudFBhdGhUb1dhbGsuc2xpY2UoMiksIHRyZWVUb1JlY3JlYXRlWzFdW3BhcmFsbGVsUm91dGVLZXldKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJlZVRvUmVjcmVhdGU7XG59XG4vLyBUT0RPLUFQUDogUmVwbGFjZSB3aXRoIG5ldyBSZWFjdCBBUEkgZm9yIGZpbmRpbmcgZG9tIG5vZGVzIHdpdGhvdXQgYSBgcmVmYCB3aGVuIGF2YWlsYWJsZVxuLyoqXG4gKiBXcmFwcyBSZWFjdERPTS5maW5kRE9NTm9kZSB3aXRoIGFkZGl0aW9uYWwgbG9naWMgdG8gaGlkZSBSZWFjdCBTdHJpY3QgTW9kZSB3YXJuaW5nXG4gKi8gZnVuY3Rpb24gZmluZERPTU5vZGUoaW5zdGFuY2UpIHtcbiAgICAvLyBUcmVlLXNoYWtlIGZvciBzZXJ2ZXIgYnVuZGxlXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBudWxsO1xuICAgIC8vIE9ubHkgYXBwbHkgc3RyaWN0IG1vZGUgd2FybmluZyB3aGVuIG5vdCBpbiBwcm9kdWN0aW9uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBjb25zdCBvcmlnaW5hbENvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZm9yKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbWVzc2FnZXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKXtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElnbm9yZSBzdHJpY3QgbW9kZSB3YXJuaW5nIGZvciB0aGUgZmluZERvbU5vZGUgY2FsbCBiZWxvd1xuICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZXNbMF0uaW5jbHVkZXMoXCJXYXJuaW5nOiAlcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsQ29uc29sZUVycm9yKC4uLm1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIF9yZWFjdGRvbS5kZWZhdWx0LmZpbmRET01Ob2RlKGluc3RhbmNlKTtcbiAgICAgICAgfSBmaW5hbGx5e1xuICAgICAgICAgICAgY29uc29sZS5lcnJvciA9IG9yaWdpbmFsQ29uc29sZUVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcmVhY3Rkb20uZGVmYXVsdC5maW5kRE9NTm9kZShpbnN0YW5jZSk7XG59XG5jb25zdCByZWN0UHJvcGVydGllcyA9IFtcbiAgICBcImJvdHRvbVwiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJ3aWR0aFwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiXG5dO1xuLyoqXG4gKiBDaGVjayBpZiBhIEhUTUxFbGVtZW50IGlzIGhpZGRlbiBvciBmaXhlZC9zdGlja3kgcG9zaXRpb25cbiAqLyBmdW5jdGlvbiBzaG91bGRTa2lwRWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gd2UgaWdub3JlIGZpeGVkIG9yIHN0aWNreSBwb3NpdGlvbmVkIGVsZW1lbnRzIHNpbmNlIHRoZXknbGwgbGlrZWx5IHBhc3MgdGhlIFwiaW4tdmlld3BvcnRcIiBjaGVja1xuICAgIC8vIGFuZCB3aWxsIHJlc3VsdCBpbiBhIHNpdHVhdGlvbiB3ZSBiYWlsIG9uIHNjcm9sbCBiZWNhdXNlIG9mIHNvbWV0aGluZyBsaWtlIGEgZml4ZWQgbmF2LFxuICAgIC8vIGV2ZW4gdGhvdWdoIHRoZSBhY3R1YWwgcGFnZSBjb250ZW50IGlzIG9mZnNjcmVlblxuICAgIGlmIChbXG4gICAgICAgIFwic3RpY2t5XCIsXG4gICAgICAgIFwiZml4ZWRcIlxuICAgIF0uaW5jbHVkZXMoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNraXBwaW5nIGF1dG8tc2Nyb2xsIGJlaGF2aW9yIGR1ZSB0byBgcG9zaXRpb246IHN0aWNreWAgb3IgYHBvc2l0aW9uOiBmaXhlZGAgb24gZWxlbWVudDpcIiwgZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIFVzZXMgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgdG8gY2hlY2sgaWYgdGhlIGVsZW1lbnQgaXMgaGlkZGVuIGluc3RlYWQgb2YgYG9mZnNldFBhcmVudGBcbiAgICAvLyBiZWNhdXNlIGBvZmZzZXRQYXJlbnRgIGRvZXNuJ3QgY29uc2lkZXIgZG9jdW1lbnQvYm9keVxuICAgIGNvbnN0IHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiByZWN0UHJvcGVydGllcy5ldmVyeSgoaXRlbSk9PnJlY3RbaXRlbV0gPT09IDApO1xufVxuLyoqXG4gKiBDaGVjayBpZiB0aGUgdG9wIGNvcm5lciBvZiB0aGUgSFRNTEVsZW1lbnQgaXMgaW4gdGhlIHZpZXdwb3J0LlxuICovIGZ1bmN0aW9uIHRvcE9mRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCwgdmlld3BvcnRIZWlnaHQpIHtcbiAgICBjb25zdCByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LnRvcCA8PSB2aWV3cG9ydEhlaWdodDtcbn1cbi8qKlxuICogRmluZCB0aGUgRE9NIG5vZGUgZm9yIGEgaGFzaCBmcmFnbWVudC5cbiAqIElmIGB0b3BgIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIHRvcCBvZiB0aGUgcGFnZS4gVGhpcyBtaXJyb3JzIHRoZSBicm93c2VyJ3MgYmVoYXZpb3IuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gKiBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhIG5hbWUsIHRoZSBwYWdlIGhhcyB0byBzY3JvbGwgdG8gdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCB0aGF0IG5hbWUuXG4gKi8gZnVuY3Rpb24gZ2V0SGFzaEZyYWdtZW50RG9tTm9kZShoYXNoRnJhZ21lbnQpIHtcbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBgdG9wYCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSB0b3Agb2YgdGhlIHBhZ2UuXG4gICAgaWYgKGhhc2hGcmFnbWVudCA9PT0gXCJ0b3BcIikge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgICB9XG4gICAgdmFyIF9kb2N1bWVudF9nZXRFbGVtZW50QnlJZDtcbiAgICAvLyBJZiB0aGUgaGFzaCBmcmFnbWVudCBpcyBhbiBpZCwgdGhlIHBhZ2UgaGFzIHRvIHNjcm9sbCB0byB0aGUgZWxlbWVudCB3aXRoIHRoYXQgaWQuXG4gICAgcmV0dXJuIChfZG9jdW1lbnRfZ2V0RWxlbWVudEJ5SWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChoYXNoRnJhZ21lbnQpKSAhPSBudWxsID8gX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkIDogLy8gSWYgdGhlIGhhc2ggZnJhZ21lbnQgaXMgYSBuYW1lLCB0aGUgcGFnZSBoYXMgdG8gc2Nyb2xsIHRvIHRoZSBmaXJzdCBlbGVtZW50IHdpdGggdGhhdCBuYW1lLlxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKGhhc2hGcmFnbWVudClbMF07XG59XG5jbGFzcyBJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlciBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUG90ZW50aWFsU2Nyb2xsKCk7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGlzIHByb3BlcnR5IGlzIG92ZXJ3cml0dGVuIGluIGhhbmRsZVBvdGVudGlhbFNjcm9sbCBpdCdzIGZpbmUgdG8gYWx3YXlzIHJ1biBpdCB3aGVuIHRydWUgYXMgaXQnbGwgYmUgc2V0IHRvIGZhbHNlIGZvciBzdWJzZXF1ZW50IHJlbmRlcnMuXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5KSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVBvdGVudGlhbFNjcm9sbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3Mpe1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb3RlbnRpYWxTY3JvbGwgPSAoKT0+e1xuICAgICAgICAgICAgLy8gSGFuZGxlIHNjcm9sbCBhbmQgZm9jdXMsIGl0J3Mgb25seSBhcHBsaWVkIG9uY2UgaW4gdGhlIGZpcnN0IHVzZUVmZmVjdCB0aGF0IHRyaWdnZXJzIHRoYXQgY2hhbmdlZC5cbiAgICAgICAgICAgIGNvbnN0IHsgZm9jdXNBbmRTY3JvbGxSZWYsIHNlZ21lbnRQYXRoIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgaWYgKGZvY3VzQW5kU2Nyb2xsUmVmLmFwcGx5KSB7XG4gICAgICAgICAgICAgICAgLy8gc2VnbWVudFBhdGhzIGlzIGFuIGFycmF5IG9mIHNlZ21lbnQgcGF0aHMgdGhhdCBzaG91bGQgYmUgc2Nyb2xsZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBzZWdtZW50IHBhdGggaXMgbm90IGluIHRoZSBhcnJheSwgdGhlIHNjcm9sbCBpcyBub3QgYXBwbGllZFxuICAgICAgICAgICAgICAgIC8vIHVubGVzcyB0aGUgYXJyYXkgaXMgZW1wdHksIGluIHdoaWNoIGNhc2UgdGhlIHNjcm9sbCBpcyBhbHdheXMgYXBwbGllZFxuICAgICAgICAgICAgICAgIGlmIChmb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMubGVuZ3RoICE9PSAwICYmICFmb2N1c0FuZFNjcm9sbFJlZi5zZWdtZW50UGF0aHMuc29tZSgoc2Nyb2xsUmVmU2VnbWVudFBhdGgpPT5zZWdtZW50UGF0aC5ldmVyeSgoc2VnbWVudCwgaW5kZXgpPT4oMCwgX21hdGNoc2VnbWVudHMubWF0Y2hTZWdtZW50KShzZWdtZW50LCBzY3JvbGxSZWZTZWdtZW50UGF0aFtpbmRleF0pKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzaEZyYWdtZW50ID0gZm9jdXNBbmRTY3JvbGxSZWYuaGFzaEZyYWdtZW50O1xuICAgICAgICAgICAgICAgIGlmIChoYXNoRnJhZ21lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tTm9kZSA9IGdldEhhc2hGcmFnbWVudERvbU5vZGUoaGFzaEZyYWdtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYGZpbmRET01Ob2RlYCBpcyB0cmlja3kgYmVjYXVzZSBpdCByZXR1cm5zIGp1c3QgdGhlIGZpcnN0IGNoaWxkIGlmIHRoZSBjb21wb25lbnQgaXMgYSBmcmFnbWVudC5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscmVhZHkgY2F1c2VkIGEgYnVnIHdoZXJlIHRoZSBmaXJzdCBjaGlsZCB3YXMgYSA8bGluay8+IGluIGhlYWQuXG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbU5vZGUgPSBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gRE9NIG5vZGUgdGhpcyBsYXlvdXQtcm91dGVyIGxldmVsIGlzIHNraXBwZWQuIEl0J2xsIGJlIGhhbmRsZWQgaGlnaGVyLXVwIGluIHRoZSB0cmVlLlxuICAgICAgICAgICAgICAgIGlmICghKGRvbU5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFZlcmlmeSBpZiB0aGUgZWxlbWVudCBpcyBhIEhUTUxFbGVtZW50IGFuZCBpZiB3ZSB3YW50IHRvIGNvbnNpZGVyIGl0IGZvciBzY3JvbGwgYmVoYXZpb3IuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgc2tpcHBlZCwgdHJ5IHRvIHNlbGVjdCB0aGUgbmV4dCBzaWJsaW5nIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgd2hpbGUoIShkb21Ob2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHx8IHNob3VsZFNraXBFbGVtZW50KGRvbU5vZGUpKXtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm8gc2libGluZ3MgZm91bmQgdGhhdCBtYXRjaCB0aGUgY3JpdGVyaWEgYXJlIGZvdW5kLCBzbyBoYW5kbGUgc2Nyb2xsIGhpZ2hlciB1cCBpbiB0aGUgdHJlZSBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb21Ob2RlID0gZG9tTm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXRlIGlzIG11dGF0ZWQgdG8gZW5zdXJlIHRoYXQgdGhlIGZvY3VzIGFuZCBzY3JvbGwgaXMgYXBwbGllZCBvbmx5IG9uY2UuXG4gICAgICAgICAgICAgICAgZm9jdXNBbmRTY3JvbGxSZWYuYXBwbHkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5oYXNoRnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmLnNlZ21lbnRQYXRocyA9IFtdO1xuICAgICAgICAgICAgICAgICgwLCBfaGFuZGxlc21vb3Roc2Nyb2xsLmhhbmRsZVNtb290aFNjcm9sbCkoKCk9PntcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSBvZiBoYXNoIHNjcm9sbCwgd2Ugb25seSBuZWVkIHRvIHNjcm9sbCB0aGUgZWxlbWVudCBpbnRvIHZpZXdcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9tTm9kZS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBjdXJyZW50IHZpZXdwb3J0IGhlaWdodCBiZWNhdXNlIHJlYWRpbmcgYGNsaWVudEhlaWdodGAgY2F1c2VzIGEgcmVmbG93LFxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgaXQgd29uJ3QgY2hhbmdlIGR1cmluZyB0aGlzIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sRWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBodG1sRWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlbGVtZW50J3MgdG9wIGVkZ2UgaXMgYWxyZWFkeSBpbiB0aGUgdmlld3BvcnQsIGV4aXQgZWFybHkuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0b3BPZkVsZW1lbnRJblZpZXdwb3J0KGRvbU5vZGUsIHZpZXdwb3J0SGVpZ2h0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdHJ5IHNjcm9sbGluZyBnbyB0aGUgdG9wIG9mIHRoZSBkb2N1bWVudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlIHdpdGggcGFnZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc2Nyb2xsSW50b1ZpZXcoKSBjYWxsZWQgb24gYDxodG1sLz5gIGVsZW1lbnQgc2Nyb2xscyBob3Jpem9udGFsbHkgb24gY2hyb21lIGFuZCBmaXJlZm94ICh0aGF0IHNob3VsZG4ndCBoYXBwZW4pXG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGNvdWxkIHVzZSBpdCB0byBzY3JvbGwgaG9yaXpvbnRhbGx5IGZvbGxvd2luZyBSVEwgYnV0IHRoYXQgYWxzbyBzZWVtcyB0byBiZSBicm9rZW4gLSBpdCB3aWxsIGFsd2F5cyBzY3JvbGwgbGVmdFxuICAgICAgICAgICAgICAgICAgICAvLyBzY3JvbGxMZWZ0ID0gMCBhbHNvIHNlZW1zIHRvIGlnbm9yZSBSVEwgYW5kIG1hbnVhbGx5IGNoZWNraW5nIGZvciBSVEwgaXMgdG9vIG11Y2ggaGFzc2xlIHNvIHdlIHdpbGwgc2Nyb2xsIGp1c3QgdmVydGljYWxseVxuICAgICAgICAgICAgICAgICAgICBodG1sRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBTY3JvbGwgdG8gZG9tTm9kZSBpZiBkb21Ob2RlIGlzIG5vdCBpbiB2aWV3cG9ydCB3aGVuIHNjcm9sbGVkIHRvIHRvcCBvZiBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRvcE9mRWxlbWVudEluVmlld3BvcnQoZG9tTm9kZSwgdmlld3BvcnRIZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkb21Ob2RlLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIHdpbGwgZm9yY2UgbGF5b3V0IGJ5IHF1ZXJ5aW5nIGRvbU5vZGUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgZG9udEZvcmNlTGF5b3V0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogZm9jdXNBbmRTY3JvbGxSZWYub25seUhhc2hDaGFuZ2VcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBNdXRhdGUgYWZ0ZXIgc2Nyb2xsaW5nIHNvIHRoYXQgaXQgY2FuIGJlIHJlYWQgYnkgYGhhbmRsZVNtb290aFNjcm9sbGBcbiAgICAgICAgICAgICAgICBmb2N1c0FuZFNjcm9sbFJlZi5vbmx5SGFzaENoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIC8vIFNldCBmb2N1cyBvbiB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBTY3JvbGxBbmRGb2N1c0hhbmRsZXIocGFyYW0pIHtcbiAgICBsZXQgeyBzZWdtZW50UGF0aCwgY2hpbGRyZW4gfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5HbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YXJpYW50IGdsb2JhbCBsYXlvdXQgcm91dGVyIG5vdCBtb3VudGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShJbm5lclNjcm9sbEFuZEZvY3VzSGFuZGxlciwge1xuICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgIGZvY3VzQW5kU2Nyb2xsUmVmOiBjb250ZXh0LmZvY3VzQW5kU2Nyb2xsUmVmLFxuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW5cbiAgICB9KTtcbn1cbi8qKlxuICogSW5uZXJMYXlvdXRSb3V0ZXIgaGFuZGxlcyByZW5kZXJpbmcgdGhlIHByb3ZpZGVkIHNlZ21lbnQgYmFzZWQgb24gdGhlIGNhY2hlLlxuICovIGZ1bmN0aW9uIElubmVyTGF5b3V0Um91dGVyKHBhcmFtKSB7XG4gICAgbGV0IHsgcGFyYWxsZWxSb3V0ZXJLZXksIHVybCwgY2hpbGROb2Rlcywgc2VnbWVudFBhdGgsIHRyZWUsIC8vIFRPRE8tQVBQOiBpbXBsZW1lbnQgYDxPZmZzY3JlZW4+YCB3aGVuIGF2YWlsYWJsZS5cbiAgICAvLyBpc0FjdGl2ZSxcbiAgICBjYWNoZUtleSB9ID0gcGFyYW07XG4gICAgY29uc3QgY29udGV4dCA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGlmICghY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhcmlhbnQgZ2xvYmFsIGxheW91dCByb3V0ZXIgbm90IG1vdW50ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgYnVpbGRJZCwgY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSwgdHJlZTogZnVsbFRyZWUgfSA9IGNvbnRleHQ7XG4gICAgLy8gUmVhZCBzZWdtZW50IHBhdGggZnJvbSB0aGUgcGFyYWxsZWwgcm91dGVyIGNhY2hlIG5vZGUuXG4gICAgbGV0IGNoaWxkTm9kZSA9IGNoaWxkTm9kZXMuZ2V0KGNhY2hlS2V5KTtcbiAgICAvLyBXaGVuIGRhdGEgaXMgbm90IGF2YWlsYWJsZSBkdXJpbmcgcmVuZGVyaW5nIGNsaWVudC1zaWRlIHdlIG5lZWQgdG8gZmV0Y2hcbiAgICAvLyBpdCBmcm9tIHRoZSBzZXJ2ZXIuXG4gICAgaWYgKGNoaWxkTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG5ld0xhenlDYWNoZU5vZGUgPSB7XG4gICAgICAgICAgICBsYXp5RGF0YTogbnVsbCxcbiAgICAgICAgICAgIHJzYzogbnVsbCxcbiAgICAgICAgICAgIHByZWZldGNoUnNjOiBudWxsLFxuICAgICAgICAgICAgaGVhZDogbnVsbCxcbiAgICAgICAgICAgIHBhcmFsbGVsUm91dGVzOiBuZXcgTWFwKClcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICogRmxpZ2h0IGRhdGEgZmV0Y2gga2lja2VkIG9mZiBkdXJpbmcgcmVuZGVyIGFuZCBwdXQgaW50byB0aGUgY2FjaGUuXG4gICAgICovIGNoaWxkTm9kZSA9IG5ld0xhenlDYWNoZU5vZGU7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KGNhY2hlS2V5LCBuZXdMYXp5Q2FjaGVOb2RlKTtcbiAgICB9XG4gICAgLy8gYHJzY2AgcmVwcmVzZW50cyB0aGUgcmVuZGVyYWJsZSBub2RlIGZvciB0aGlzIHNlZ21lbnQuXG4gICAgLy8gSWYgdGhpcyBzZWdtZW50IGhhcyBhIGBwcmVmZXRjaFJzY2AsIGl0J3MgdGhlIHN0YXRpY2FsbHkgcHJlZmV0Y2hlZCBkYXRhLlxuICAgIC8vIFdlIHNob3VsZCB1c2UgdGhhdCBvbiBpbml0aWFsIHJlbmRlciBpbnN0ZWFkIG9mIGByc2NgLiBUaGVuIHdlJ2xsIHN3aXRjaFxuICAgIC8vIHRvIGByc2NgIHdoZW4gdGhlIGR5bmFtaWMgcmVzcG9uc2Ugc3RyZWFtcyBpbi5cbiAgICAvL1xuICAgIC8vIElmIG5vIHByZWZldGNoIGRhdGEgaXMgYXZhaWxhYmxlLCB0aGVuIHdlIGdvIHN0cmFpZ2h0IHRvIHJlbmRlcmluZyBgcnNjYC5cbiAgICBjb25zdCByZXNvbHZlZFByZWZldGNoUnNjID0gY2hpbGROb2RlLnByZWZldGNoUnNjICE9PSBudWxsID8gY2hpbGROb2RlLnByZWZldGNoUnNjIDogY2hpbGROb2RlLnJzYztcbiAgICAvLyBXZSB1c2UgYHVzZURlZmVycmVkVmFsdWVgIHRvIGhhbmRsZSBzd2l0Y2hpbmcgYmV0d2VlbiB0aGUgcHJlZmV0Y2hlZCBhbmRcbiAgICAvLyBmaW5hbCB2YWx1ZXMuIFRoZSBzZWNvbmQgYXJndW1lbnQgaXMgcmV0dXJuZWQgb24gaW5pdGlhbCByZW5kZXIsIHRoZW4gaXRcbiAgICAvLyByZS1yZW5kZXJzIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgIC8vXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIGB1c2VEZWZlcnJlZFZhbHVlYCBpcyBvbmx5XG4gICAgLy8gYXZhaWxhYmxlIGluIHRoZSBleHBlcmltZW50YWwgYnVpbGRzLiBXaGVuIGl0cyBkaXNhYmxlZCwgaXQgd2lsbCBhbHdheXNcbiAgICAvLyByZXR1cm4gYHJzY2AuXG4gICAgY29uc3QgcnNjID0gKDAsIF9yZWFjdC51c2VEZWZlcnJlZFZhbHVlKShjaGlsZE5vZGUucnNjLCByZXNvbHZlZFByZWZldGNoUnNjKTtcbiAgICAvLyBgcnNjYCBpcyBlaXRoZXIgYSBSZWFjdCBub2RlIG9yIGEgcHJvbWlzZSBmb3IgYSBSZWFjdCBub2RlLCBleGNlcHQgd2VcbiAgICAvLyBzcGVjaWFsIGNhc2UgYG51bGxgIHRvIHJlcHJlc2VudCB0aGF0IHRoaXMgc2VnbWVudCdzIGRhdGEgaXMgbWlzc2luZy4gSWZcbiAgICAvLyBpdCdzIGEgcHJvbWlzZSwgd2UgbmVlZCB0byB1bndyYXAgaXQgc28gd2UgY2FuIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICAvLyBkYXRhIGlzIG1pc3NpbmcuXG4gICAgY29uc3QgcmVzb2x2ZWRSc2MgPSB0eXBlb2YgcnNjID09PSBcIm9iamVjdFwiICYmIHJzYyAhPT0gbnVsbCAmJiB0eXBlb2YgcnNjLnRoZW4gPT09IFwiZnVuY3Rpb25cIiA/ICgwLCBfcmVhY3QudXNlKShyc2MpIDogcnNjO1xuICAgIGlmICghcmVzb2x2ZWRSc2MpIHtcbiAgICAgICAgLy8gVGhlIGRhdGEgZm9yIHRoaXMgc2VnbWVudCBpcyBub3QgYXZhaWxhYmxlLCBhbmQgdGhlcmUncyBubyBwZW5kaW5nXG4gICAgICAgIC8vIG5hdmlnYXRpb24gdGhhdCB3aWxsIGJlIGFibGUgdG8gZnVsZmlsbCBpdC4gV2UgbmVlZCB0byBmZXRjaCBtb3JlIGZyb21cbiAgICAgICAgLy8gdGhlIHNlcnZlciBhbmQgcGF0Y2ggdGhlIGNhY2hlLlxuICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGFscmVhZHkgYSBwZW5kaW5nIHJlcXVlc3QuXG4gICAgICAgIGxldCBsYXp5RGF0YSA9IGNoaWxkTm9kZS5sYXp5RGF0YTtcbiAgICAgICAgaWYgKGxhenlEYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAqIFJvdXRlciBzdGF0ZSB3aXRoIHJlZmV0Y2ggbWFya2VyIGFkZGVkXG4gICAgICAgKi8gLy8gVE9ETy1BUFA6IHJlbW92ZSAnJ1xuICAgICAgICAgICAgY29uc3QgcmVmZXRjaFRyZWUgPSB3YWxrQWRkUmVmZXRjaChbXG4gICAgICAgICAgICAgICAgXCJcIixcbiAgICAgICAgICAgICAgICAuLi5zZWdtZW50UGF0aFxuICAgICAgICAgICAgXSwgZnVsbFRyZWUpO1xuICAgICAgICAgICAgY2hpbGROb2RlLmxhenlEYXRhID0gbGF6eURhdGEgPSAoMCwgX2ZldGNoc2VydmVycmVzcG9uc2UuZmV0Y2hTZXJ2ZXJSZXNwb25zZSkobmV3IFVSTCh1cmwsIGxvY2F0aW9uLm9yaWdpbiksIHJlZmV0Y2hUcmVlLCBjb250ZXh0Lm5leHRVcmwsIGJ1aWxkSWQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAqIEZsaWdodCByZXNwb25zZSBkYXRhXG4gICAgICovIC8vIFdoZW4gdGhlIGRhdGEgaGFzIG5vdCByZXNvbHZlZCB5ZXQgYHVzZWAgd2lsbCBzdXNwZW5kIGhlcmUuXG4gICAgICAgIGNvbnN0IFtmbGlnaHREYXRhLCBvdmVycmlkZUNhbm9uaWNhbFVybF0gPSAoMCwgX3JlYWN0LnVzZSkobGF6eURhdGEpO1xuICAgICAgICAvLyBzZWdtZW50UGF0aCBmcm9tIHRoZSBzZXJ2ZXIgZG9lcyBub3QgbWF0Y2ggdGhlIGxheW91dCdzIHNlZ21lbnRQYXRoXG4gICAgICAgIGNoaWxkTm9kZS5sYXp5RGF0YSA9IG51bGw7XG4gICAgICAgIC8vIHNldFRpbWVvdXQgaXMgdXNlZCB0byBzdGFydCBhIG5ldyB0cmFuc2l0aW9uIGR1cmluZyByZW5kZXIsIHRoaXMgaXMgYW4gaW50ZW50aW9uYWwgaGFjayBhcm91bmQgUmVhY3QuXG4gICAgICAgIHNldFRpbWVvdXQoKCk9PntcbiAgICAgICAgICAgICgwLCBfcmVhY3Quc3RhcnRUcmFuc2l0aW9uKSgoKT0+e1xuICAgICAgICAgICAgICAgIGNoYW5nZUJ5U2VydmVyUmVzcG9uc2UoZnVsbFRyZWUsIGZsaWdodERhdGEsIG92ZXJyaWRlQ2Fub25pY2FsVXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3VzcGVuZCBpbmZpbml0ZWx5IGFzIGBjaGFuZ2VCeVNlcnZlclJlc3BvbnNlYCB3aWxsIGNhdXNlIGEgZGlmZmVyZW50IHBhcnQgb2YgdGhlIHRyZWUgdG8gYmUgcmVuZGVyZWQuXG4gICAgICAgICgwLCBfcmVhY3QudXNlKSgoMCwgX2luZmluaXRlcHJvbWlzZS5jcmVhdGVJbmZpbml0ZVByb21pc2UpKCkpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBnZXQgdG8gdGhpcyBwb2ludCwgdGhlbiB3ZSBrbm93IHdlIGhhdmUgc29tZXRoaW5nIHdlIGNhbiByZW5kZXIuXG4gICAgY29uc3Qgc3VidHJlZSA9IC8vIFRoZSBsYXlvdXQgcm91dGVyIGNvbnRleHQgbmFycm93cyBkb3duIHRyZWUgYW5kIGNoaWxkTm9kZXMgYXQgZWFjaCBsZXZlbC5cbiAgICAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5MYXlvdXRSb3V0ZXJDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICB0cmVlOiB0cmVlWzFdW3BhcmFsbGVsUm91dGVyS2V5XSxcbiAgICAgICAgICAgIGNoaWxkTm9kZXM6IGNoaWxkTm9kZS5wYXJhbGxlbFJvdXRlcyxcbiAgICAgICAgICAgIC8vIFRPRE8tQVBQOiBvdmVycmlkaW5nIG9mIHVybCBmb3IgcGFyYWxsZWwgcm91dGVzXG4gICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogcmVzb2x2ZWRSc2NcbiAgICB9KTtcbiAgICAvLyBFbnN1cmUgcm9vdCBsYXlvdXQgaXMgbm90IHdyYXBwZWQgaW4gYSBkaXYgYXMgdGhlIHJvb3QgbGF5b3V0IHJlbmRlcnMgYDxodG1sPmBcbiAgICByZXR1cm4gc3VidHJlZTtcbn1cbi8qKlxuICogUmVuZGVycyBzdXNwZW5zZSBib3VuZGFyeSB3aXRoIHRoZSBwcm92aWRlZCBcImxvYWRpbmdcIiBwcm9wZXJ0eSBhcyB0aGUgZmFsbGJhY2suXG4gKiBJZiBubyBsb2FkaW5nIHByb3BlcnR5IGlzIHByb3ZpZGVkIGl0IHJlbmRlcnMgdGhlIGNoaWxkcmVuIHdpdGhvdXQgYSBzdXNwZW5zZSBib3VuZGFyeS5cbiAqLyBmdW5jdGlvbiBMb2FkaW5nQm91bmRhcnkocGFyYW0pIHtcbiAgICBsZXQgeyBjaGlsZHJlbiwgbG9hZGluZywgbG9hZGluZ1N0eWxlcywgbG9hZGluZ1NjcmlwdHMsIGhhc0xvYWRpbmcgfSA9IHBhcmFtO1xuICAgIGlmIChoYXNMb2FkaW5nKSB7XG4gICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9yZWFjdC5TdXNwZW5zZSwge1xuICAgICAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NjcmlwdHMsXG4gICAgICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoX2pzeHJ1bnRpbWUuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSk7XG59XG5mdW5jdGlvbiBPdXRlckxheW91dFJvdXRlcihwYXJhbSkge1xuICAgIGxldCB7IHBhcmFsbGVsUm91dGVyS2V5LCBzZWdtZW50UGF0aCwgZXJyb3IsIGVycm9yU3R5bGVzLCBlcnJvclNjcmlwdHMsIHRlbXBsYXRlU3R5bGVzLCB0ZW1wbGF0ZVNjcmlwdHMsIGxvYWRpbmcsIGxvYWRpbmdTdHlsZXMsIGxvYWRpbmdTY3JpcHRzLCBoYXNMb2FkaW5nLCB0ZW1wbGF0ZSwgbm90Rm91bmQsIG5vdEZvdW5kU3R5bGVzLCBzdHlsZXMgfSA9IHBhcmFtO1xuICAgIGNvbnN0IGNvbnRleHQgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YXJpYW50IGV4cGVjdGVkIGxheW91dCByb3V0ZXIgdG8gYmUgbW91bnRlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgeyBjaGlsZE5vZGVzLCB0cmVlLCB1cmwgfSA9IGNvbnRleHQ7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBhcmFsbGVsUm91dGVyIGNhY2hlIG5vZGVcbiAgICBsZXQgY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyID0gY2hpbGROb2Rlcy5nZXQocGFyYWxsZWxSb3V0ZXJLZXkpO1xuICAgIC8vIElmIHRoZSBwYXJhbGxlbCByb3V0ZXIgY2FjaGUgbm9kZSBkb2VzIG5vdCBleGlzdCB5ZXQsIGNyZWF0ZSBpdC5cbiAgICAvLyBUaGlzIHdyaXRlcyB0byB0aGUgY2FjaGUgd2hlbiB0aGVyZSBpcyBubyBpdGVtIGluIHRoZSBjYWNoZSB5ZXQuIEl0IG5ldmVyICpvdmVyd3JpdGVzKiBleGlzdGluZyBjYWNoZSBpdGVtcyB3aGljaCBpcyB3aHkgaXQncyBzYWZlIGluIGNvbmN1cnJlbnQgbW9kZS5cbiAgICBpZiAoIWNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlcikge1xuICAgICAgICBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KHBhcmFsbGVsUm91dGVyS2V5LCBjaGlsZE5vZGVzRm9yUGFyYWxsZWxSb3V0ZXIpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGFjdGl2ZSBzZWdtZW50IGluIHRoZSB0cmVlXG4gICAgLy8gVGhlIHJlYXNvbiBhcnJheXMgYXJlIHVzZWQgaW4gdGhlIGRhdGEgZm9ybWF0IGlzIHRoYXQgdGhlc2UgYXJlIHRyYW5zZmVycmVkIGZyb20gdGhlIHNlcnZlciB0byB0aGUgYnJvd3NlciBzbyBpdCdzIG9wdGltaXplZCB0byBzYXZlIGJ5dGVzLlxuICAgIGNvbnN0IHRyZWVTZWdtZW50ID0gdHJlZVsxXVtwYXJhbGxlbFJvdXRlcktleV1bMF07XG4gICAgLy8gSWYgc2VnbWVudCBpcyBhbiBhcnJheSBpdCdzIGEgZHluYW1pYyByb3V0ZSBhbmQgd2Ugd2FudCB0byByZWFkIHRoZSBkeW5hbWljIHJvdXRlIHZhbHVlIGFzIHRoZSBzZWdtZW50IHRvIGdldCBmcm9tIHRoZSBjYWNoZS5cbiAgICBjb25zdCBjdXJyZW50Q2hpbGRTZWdtZW50VmFsdWUgPSAoMCwgX2dldHNlZ21lbnR2YWx1ZS5nZXRTZWdtZW50VmFsdWUpKHRyZWVTZWdtZW50KTtcbiAgICAvKipcbiAgICogRGVjaWRlcyB3aGljaCBzZWdtZW50cyB0byBrZWVwIHJlbmRlcmluZywgYWxsIHNlZ21lbnRzIHRoYXQgYXJlIG5vdCBhY3RpdmUgd2lsbCBiZSB3cmFwcGVkIGluIGA8T2Zmc2NyZWVuPmAuXG4gICAqLyAvLyBUT0RPLUFQUDogQWRkIGhhbmRsaW5nIG9mIGA8T2Zmc2NyZWVuPmAgd2hlbiBpdCdzIGF2YWlsYWJsZS5cbiAgICBjb25zdCBwcmVzZXJ2ZWRTZWdtZW50cyA9IFtcbiAgICAgICAgdHJlZVNlZ21lbnRcbiAgICBdO1xuICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShfanN4cnVudGltZS5GcmFnbWVudCwge1xuICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgc3R5bGVzLFxuICAgICAgICAgICAgcHJlc2VydmVkU2VnbWVudHMubWFwKChwcmVzZXJ2ZWRTZWdtZW50KT0+e1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXNlcnZlZFNlZ21lbnRWYWx1ZSA9ICgwLCBfZ2V0c2VnbWVudHZhbHVlLmdldFNlZ21lbnRWYWx1ZSkocHJlc2VydmVkU2VnbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FjaGVLZXkgPSAoMCwgX2NyZWF0ZXJvdXRlcmNhY2hla2V5LmNyZWF0ZVJvdXRlckNhY2hlS2V5KShwcmVzZXJ2ZWRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4oLypcbiAgICAgICAgICAgIC0gRXJyb3IgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgZXJyb3IgYm91bmRhcnkgaWYgZXJyb3IgY29tcG9uZW50IGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gZXJyb3Igc3RhdGUuXG4gICAgICAgICAgICAtIExvYWRpbmcgYm91bmRhcnlcbiAgICAgICAgICAgICAgLSBPbmx5IHJlbmRlcnMgc3VzcGVuc2UgYm91bmRhcnkgaWYgbG9hZGluZyBjb21wb25lbnRzIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAtIFJlbmRlcmVkIGZvciBlYWNoIHNlZ21lbnQgdG8gZW5zdXJlIHRoZXkgaGF2ZSB0aGVpciBvd24gbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgICAgLSBQYXNzZWQgdG8gdGhlIHJvdXRlciBkdXJpbmcgcmVuZGVyaW5nIHRvIGVuc3VyZSBpdCBjYW4gYmUgaW1tZWRpYXRlbHkgcmVuZGVyZWQgd2hlbiBzdXNwZW5kaW5nIG9uIGEgRmxpZ2h0IGZldGNoLlxuICAgICAgICAgICovIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeHMpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5UZW1wbGF0ZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoU2Nyb2xsQW5kRm9jdXNIYW5kbGVyLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfZXJyb3Jib3VuZGFyeS5FcnJvckJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JDb21wb25lbnQ6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yU3R5bGVzOiBlcnJvclN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvclNjcmlwdHM6IGVycm9yU2NyaXB0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShMb2FkaW5nQm91bmRhcnksIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzTG9hZGluZzogaGFzTG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZzogbG9hZGluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1N0eWxlczogbG9hZGluZ1N0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZGluZ1NjcmlwdHM6IGxvYWRpbmdTY3JpcHRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfbm90Zm91bmRib3VuZGFyeS5Ob3RGb3VuZEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogbm90Rm91bmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFN0eWxlczogbm90Rm91bmRTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogLyojX19QVVJFX18qLyAoMCwgX2pzeHJ1bnRpbWUuanN4KShfcmVkaXJlY3Rib3VuZGFyeS5SZWRpcmVjdEJvdW5kYXJ5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoSW5uZXJMYXlvdXRSb3V0ZXIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYWxsZWxSb3V0ZXJLZXk6IHBhcmFsbGVsUm91dGVyS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJlZTogdHJlZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlczogY2hpbGROb2Rlc0ZvclBhcmFsbGVsUm91dGVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdtZW50UGF0aDogc2VnbWVudFBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBjYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmU6IGN1cnJlbnRDaGlsZFNlZ21lbnRWYWx1ZSA9PT0gcHJlc2VydmVkU2VnbWVudFZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVNjcmlwdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfSwgKDAsIF9jcmVhdGVyb3V0ZXJjYWNoZWtleS5jcmVhdGVSb3V0ZXJDYWNoZUtleSkocHJlc2VydmVkU2VnbWVudCwgdHJ1ZSkpKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIF1cbiAgICB9KTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGF5b3V0LXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiT3V0ZXJMYXlvdXRSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9yZWFjdGRvbSIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9mZXRjaHNlcnZlcnJlc3BvbnNlIiwiX2luZmluaXRlcHJvbWlzZSIsIl9lcnJvcmJvdW5kYXJ5IiwiX21hdGNoc2VnbWVudHMiLCJfaGFuZGxlc21vb3Roc2Nyb2xsIiwiX3JlZGlyZWN0Ym91bmRhcnkiLCJfbm90Zm91bmRib3VuZGFyeSIsIl9nZXRzZWdtZW50dmFsdWUiLCJfY3JlYXRlcm91dGVyY2FjaGVrZXkiLCJ3YWxrQWRkUmVmZXRjaCIsInNlZ21lbnRQYXRoVG9XYWxrIiwidHJlZVRvUmVjcmVhdGUiLCJzZWdtZW50IiwicGFyYWxsZWxSb3V0ZUtleSIsImlzTGFzdCIsImxlbmd0aCIsIm1hdGNoU2VnbWVudCIsImhhc093blByb3BlcnR5Iiwic3ViVHJlZSIsInVuZGVmaW5lZCIsInNsaWNlIiwiZmluZERPTU5vZGUiLCJpbnN0YW5jZSIsInByb2Nlc3MiLCJvcmlnaW5hbENvbnNvbGVFcnJvciIsImNvbnNvbGUiLCJlcnJvciIsIl9sZW4iLCJhcmd1bWVudHMiLCJtZXNzYWdlcyIsIkFycmF5IiwiX2tleSIsImluY2x1ZGVzIiwiZGVmYXVsdCIsInJlY3RQcm9wZXJ0aWVzIiwic2hvdWxkU2tpcEVsZW1lbnQiLCJlbGVtZW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBvc2l0aW9uIiwid2FybiIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJldmVyeSIsIml0ZW0iLCJ0b3BPZkVsZW1lbnRJblZpZXdwb3J0Iiwidmlld3BvcnRIZWlnaHQiLCJ0b3AiLCJnZXRIYXNoRnJhZ21lbnREb21Ob2RlIiwiaGFzaEZyYWdtZW50IiwiZG9jdW1lbnQiLCJib2R5IiwiX2RvY3VtZW50X2dldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRFbGVtZW50c0J5TmFtZSIsIklubmVyU2Nyb2xsQW5kRm9jdXNIYW5kbGVyIiwiQ29tcG9uZW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJoYW5kbGVQb3RlbnRpYWxTY3JvbGwiLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcm9wcyIsImZvY3VzQW5kU2Nyb2xsUmVmIiwiYXBwbHkiLCJyZW5kZXIiLCJjaGlsZHJlbiIsImNvbnN0cnVjdG9yIiwiYXJncyIsInNlZ21lbnRQYXRoIiwic2VnbWVudFBhdGhzIiwic29tZSIsInNjcm9sbFJlZlNlZ21lbnRQYXRoIiwiaW5kZXgiLCJkb21Ob2RlIiwiRWxlbWVudCIsIkhUTUxFbGVtZW50IiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaGFuZGxlU21vb3RoU2Nyb2xsIiwic2Nyb2xsSW50b1ZpZXciLCJodG1sRWxlbWVudCIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInNjcm9sbFRvcCIsImRvbnRGb3JjZUxheW91dCIsIm9ubHlIYXNoQ2hhbmdlIiwiZm9jdXMiLCJTY3JvbGxBbmRGb2N1c0hhbmRsZXIiLCJwYXJhbSIsImNvbnRleHQiLCJ1c2VDb250ZXh0IiwiR2xvYmFsTGF5b3V0Um91dGVyQ29udGV4dCIsIkVycm9yIiwianN4IiwiSW5uZXJMYXlvdXRSb3V0ZXIiLCJwYXJhbGxlbFJvdXRlcktleSIsInVybCIsImNoaWxkTm9kZXMiLCJ0cmVlIiwiY2FjaGVLZXkiLCJidWlsZElkIiwiY2hhbmdlQnlTZXJ2ZXJSZXNwb25zZSIsImZ1bGxUcmVlIiwiY2hpbGROb2RlIiwibmV3TGF6eUNhY2hlTm9kZSIsImxhenlEYXRhIiwicnNjIiwicHJlZmV0Y2hSc2MiLCJoZWFkIiwicGFyYWxsZWxSb3V0ZXMiLCJNYXAiLCJzZXQiLCJyZXNvbHZlZFByZWZldGNoUnNjIiwidXNlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVkUnNjIiwidGhlbiIsInVzZSIsInJlZmV0Y2hUcmVlIiwiZmV0Y2hTZXJ2ZXJSZXNwb25zZSIsIlVSTCIsImxvY2F0aW9uIiwib3JpZ2luIiwibmV4dFVybCIsImZsaWdodERhdGEiLCJvdmVycmlkZUNhbm9uaWNhbFVybCIsInNldFRpbWVvdXQiLCJzdGFydFRyYW5zaXRpb24iLCJjcmVhdGVJbmZpbml0ZVByb21pc2UiLCJzdWJ0cmVlIiwiTGF5b3V0Um91dGVyQ29udGV4dCIsIlByb3ZpZGVyIiwiTG9hZGluZ0JvdW5kYXJ5IiwibG9hZGluZyIsImxvYWRpbmdTdHlsZXMiLCJsb2FkaW5nU2NyaXB0cyIsImhhc0xvYWRpbmciLCJTdXNwZW5zZSIsImZhbGxiYWNrIiwianN4cyIsIkZyYWdtZW50IiwiZXJyb3JTdHlsZXMiLCJlcnJvclNjcmlwdHMiLCJ0ZW1wbGF0ZVN0eWxlcyIsInRlbXBsYXRlU2NyaXB0cyIsInRlbXBsYXRlIiwibm90Rm91bmQiLCJub3RGb3VuZFN0eWxlcyIsInN0eWxlcyIsImNoaWxkTm9kZXNGb3JQYXJhbGxlbFJvdXRlciIsInRyZWVTZWdtZW50IiwiY3VycmVudENoaWxkU2VnbWVudFZhbHVlIiwiZ2V0U2VnbWVudFZhbHVlIiwicHJlc2VydmVkU2VnbWVudHMiLCJtYXAiLCJwcmVzZXJ2ZWRTZWdtZW50IiwicHJlc2VydmVkU2VnbWVudFZhbHVlIiwiY3JlYXRlUm91dGVyQ2FjaGVLZXkiLCJUZW1wbGF0ZUNvbnRleHQiLCJFcnJvckJvdW5kYXJ5IiwiZXJyb3JDb21wb25lbnQiLCJOb3RGb3VuZEJvdW5kYXJ5IiwiUmVkaXJlY3RCb3VuZGFyeSIsImlzQWN0aXZlIiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/layout-router.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js":
/*!********************************************************************!*\
  !*** ./node_modules/next/dist/client/components/match-segments.js ***!
  \********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    matchSegment: function() {\n        return matchSegment;\n    },\n    canSegmentBeOverridden: function() {\n        return canSegmentBeOverridden;\n    }\n});\nconst _getsegmentparam = __webpack_require__(/*! ../../server/app-render/get-segment-param */ \"(app-pages-browser)/./node_modules/next/dist/server/app-render/get-segment-param.js\");\nconst matchSegment = (existingSegment, segment)=>{\n    // segment is either Array or string\n    if (typeof existingSegment === \"string\") {\n        if (typeof segment === \"string\") {\n            // Common case: segment is just a string\n            return existingSegment === segment;\n        }\n        return false;\n    }\n    if (typeof segment === \"string\") {\n        return false;\n    }\n    return existingSegment[0] === segment[0] && existingSegment[1] === segment[1];\n};\nconst canSegmentBeOverridden = (existingSegment, segment)=>{\n    var _getSegmentParam;\n    if (Array.isArray(existingSegment) || !Array.isArray(segment)) {\n        return false;\n    }\n    return ((_getSegmentParam = (0, _getsegmentparam.getSegmentParam)(existingSegment)) == null ? void 0 : _getSegmentParam.param) === segment[0];\n};\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=match-segments.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbWF0Y2gtc2VnbWVudHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FHTjtBQUNBLFNBQVNHLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlULE9BQU9DLGNBQWMsQ0FBQ08sUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTCxTQUFTO0lBQ2JHLGNBQWM7UUFDVixPQUFPQTtJQUNYO0lBQ0FDLHdCQUF3QjtRQUNwQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyxtQkFBbUJDLG1CQUFPQSxDQUFDLHNJQUEyQztBQUM1RSxNQUFNVCxlQUFlLENBQUNVLGlCQUFpQkM7SUFDbkMsb0NBQW9DO0lBQ3BDLElBQUksT0FBT0Qsb0JBQW9CLFVBQVU7UUFDckMsSUFBSSxPQUFPQyxZQUFZLFVBQVU7WUFDN0Isd0NBQXdDO1lBQ3hDLE9BQU9ELG9CQUFvQkM7UUFDL0I7UUFDQSxPQUFPO0lBQ1g7SUFDQSxJQUFJLE9BQU9BLFlBQVksVUFBVTtRQUM3QixPQUFPO0lBQ1g7SUFDQSxPQUFPRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRSxJQUFJRCxlQUFlLENBQUMsRUFBRSxLQUFLQyxPQUFPLENBQUMsRUFBRTtBQUNqRjtBQUNBLE1BQU1WLHlCQUF5QixDQUFDUyxpQkFBaUJDO0lBQzdDLElBQUlDO0lBQ0osSUFBSUMsTUFBTUMsT0FBTyxDQUFDSixvQkFBb0IsQ0FBQ0csTUFBTUMsT0FBTyxDQUFDSCxVQUFVO1FBQzNELE9BQU87SUFDWDtJQUNBLE9BQU8sQ0FBQyxDQUFDQyxtQkFBbUIsQ0FBQyxHQUFHSixpQkFBaUJPLGVBQWUsRUFBRUwsZ0JBQWUsS0FBTSxPQUFPLEtBQUssSUFBSUUsaUJBQWlCSSxLQUFLLE1BQU1MLE9BQU8sQ0FBQyxFQUFFO0FBQ2pKO0FBRUEsSUFBSSxDQUFDLE9BQU9kLFFBQVFvQixPQUFPLEtBQUssY0FBZSxPQUFPcEIsUUFBUW9CLE9BQU8sS0FBSyxZQUFZcEIsUUFBUW9CLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBT3BCLFFBQVFvQixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLdkIsT0FBT0MsY0FBYyxDQUFDQyxRQUFRb0IsT0FBTyxFQUFFLGNBQWM7UUFBRW5CLE9BQU87SUFBSztJQUNuRUgsT0FBT3dCLE1BQU0sQ0FBQ3RCLFFBQVFvQixPQUFPLEVBQUVwQjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRb0IsT0FBTztBQUNsQyxFQUVBLDBDQUEwQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL21hdGNoLXNlZ21lbnRzLmpzP2JjYjEiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG4wICYmIChtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtYXRjaFNlZ21lbnQ6IG51bGwsXG4gICAgY2FuU2VnbWVudEJlT3ZlcnJpZGRlbjogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBtYXRjaFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbWF0Y2hTZWdtZW50O1xuICAgIH0sXG4gICAgY2FuU2VnbWVudEJlT3ZlcnJpZGRlbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYW5TZWdtZW50QmVPdmVycmlkZGVuO1xuICAgIH1cbn0pO1xuY29uc3QgX2dldHNlZ21lbnRwYXJhbSA9IHJlcXVpcmUoXCIuLi8uLi9zZXJ2ZXIvYXBwLXJlbmRlci9nZXQtc2VnbWVudC1wYXJhbVwiKTtcbmNvbnN0IG1hdGNoU2VnbWVudCA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgLy8gc2VnbWVudCBpcyBlaXRoZXIgQXJyYXkgb3Igc3RyaW5nXG4gICAgaWYgKHR5cGVvZiBleGlzdGluZ1NlZ21lbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBDb21tb24gY2FzZTogc2VnbWVudCBpcyBqdXN0IGEgc3RyaW5nXG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZWdtZW50ID09PSBzZWdtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nU2VnbWVudFswXSA9PT0gc2VnbWVudFswXSAmJiBleGlzdGluZ1NlZ21lbnRbMV0gPT09IHNlZ21lbnRbMV07XG59O1xuY29uc3QgY2FuU2VnbWVudEJlT3ZlcnJpZGRlbiA9IChleGlzdGluZ1NlZ21lbnQsIHNlZ21lbnQpPT57XG4gICAgdmFyIF9nZXRTZWdtZW50UGFyYW07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhpc3RpbmdTZWdtZW50KSB8fCAhQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoKF9nZXRTZWdtZW50UGFyYW0gPSAoMCwgX2dldHNlZ21lbnRwYXJhbS5nZXRTZWdtZW50UGFyYW0pKGV4aXN0aW5nU2VnbWVudCkpID09IG51bGwgPyB2b2lkIDAgOiBfZ2V0U2VnbWVudFBhcmFtLnBhcmFtKSA9PT0gc2VnbWVudFswXTtcbn07XG5cbmlmICgodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ2Z1bmN0aW9uJyB8fCAodHlwZW9mIGV4cG9ydHMuZGVmYXVsdCA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cy5kZWZhdWx0ICE9PSBudWxsKSkgJiYgdHlwZW9mIGV4cG9ydHMuZGVmYXVsdC5fX2VzTW9kdWxlID09PSAndW5kZWZpbmVkJykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cy5kZWZhdWx0LCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5kZWZhdWx0LCBleHBvcnRzKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzLmRlZmF1bHQ7XG59XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGNoLXNlZ21lbnRzLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIm1hdGNoU2VnbWVudCIsImNhblNlZ21lbnRCZU92ZXJyaWRkZW4iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJfZ2V0c2VnbWVudHBhcmFtIiwicmVxdWlyZSIsImV4aXN0aW5nU2VnbWVudCIsInNlZ21lbnQiLCJfZ2V0U2VnbWVudFBhcmFtIiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0U2VnbWVudFBhcmFtIiwicGFyYW0iLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/match-segments.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js":
/*!****************************************************************!*\
  !*** ./node_modules/next/dist/client/components/navigation.js ***!
  \****************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar _s = $RefreshSig$();\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    ReadonlyURLSearchParams: function() {\n        return ReadonlyURLSearchParams;\n    },\n    useSearchParams: function() {\n        return useSearchParams;\n    },\n    usePathname: function() {\n        return usePathname;\n    },\n    ServerInsertedHTMLContext: function() {\n        return _serverinsertedhtmlsharedruntime.ServerInsertedHTMLContext;\n    },\n    useServerInsertedHTML: function() {\n        return _serverinsertedhtmlsharedruntime.useServerInsertedHTML;\n    },\n    useRouter: function() {\n        return useRouter;\n    },\n    useParams: function() {\n        return useParams;\n    },\n    useSelectedLayoutSegments: function() {\n        return useSelectedLayoutSegments;\n    },\n    useSelectedLayoutSegment: function() {\n        return useSelectedLayoutSegment;\n    },\n    redirect: function() {\n        return _redirect.redirect;\n    },\n    permanentRedirect: function() {\n        return _redirect.permanentRedirect;\n    },\n    RedirectType: function() {\n        return _redirect.RedirectType;\n    },\n    notFound: function() {\n        return _notfound.notFound;\n    }\n});\nconst _react = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nconst _hooksclientcontextsharedruntime = __webpack_require__(/*! ../../shared/lib/hooks-client-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/hooks-client-context.shared-runtime.js\");\nconst _clienthookinservercomponenterror = __webpack_require__(/*! ./client-hook-in-server-component-error */ \"(app-pages-browser)/./node_modules/next/dist/client/components/client-hook-in-server-component-error.js\");\nconst _getsegmentvalue = __webpack_require__(/*! ./router-reducer/reducers/get-segment-value */ \"(app-pages-browser)/./node_modules/next/dist/client/components/router-reducer/reducers/get-segment-value.js\");\nconst _segment = __webpack_require__(/*! ../../shared/lib/segment */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/segment.js\");\nconst _serverinsertedhtmlsharedruntime = __webpack_require__(/*! ../../shared/lib/server-inserted-html.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/server-inserted-html.shared-runtime.js\");\nconst _redirect = __webpack_require__(/*! ./redirect */ \"(app-pages-browser)/./node_modules/next/dist/client/components/redirect.js\");\nconst _notfound = __webpack_require__(/*! ./not-found */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found.js\");\nconst INTERNAL_URLSEARCHPARAMS_INSTANCE = Symbol(\"internal for urlsearchparams readonly\");\nfunction readonlyURLSearchParamsError() {\n    return new Error(\"ReadonlyURLSearchParams cannot be modified\");\n}\nclass ReadonlyURLSearchParams {\n    [Symbol.iterator]() {\n        return this[INTERNAL_URLSEARCHPARAMS_INSTANCE][Symbol.iterator]();\n    }\n    append() {\n        throw readonlyURLSearchParamsError();\n    }\n    delete() {\n        throw readonlyURLSearchParamsError();\n    }\n    set() {\n        throw readonlyURLSearchParamsError();\n    }\n    sort() {\n        throw readonlyURLSearchParamsError();\n    }\n    constructor(urlSearchParams){\n        this[INTERNAL_URLSEARCHPARAMS_INSTANCE] = urlSearchParams;\n        this.entries = urlSearchParams.entries.bind(urlSearchParams);\n        this.forEach = urlSearchParams.forEach.bind(urlSearchParams);\n        this.get = urlSearchParams.get.bind(urlSearchParams);\n        this.getAll = urlSearchParams.getAll.bind(urlSearchParams);\n        this.has = urlSearchParams.has.bind(urlSearchParams);\n        this.keys = urlSearchParams.keys.bind(urlSearchParams);\n        this.values = urlSearchParams.values.bind(urlSearchParams);\n        this.toString = urlSearchParams.toString.bind(urlSearchParams);\n        this.size = urlSearchParams.size;\n    }\n}\nfunction useSearchParams() {\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"useSearchParams\");\n    const searchParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.SearchParamsContext);\n    // In the case where this is `null`, the compat types added in\n    // `next-env.d.ts` will add a new overload that changes the return type to\n    // include `null`.\n    const readonlySearchParams = (0, _react.useMemo)(()=>{\n        if (!searchParams) {\n            // When the router is not ready in pages, we won't have the search params\n            // available.\n            return null;\n        }\n        return new ReadonlyURLSearchParams(searchParams);\n    }, [\n        searchParams\n    ]);\n    if (false) {}\n    return readonlySearchParams;\n}\nfunction usePathname() {\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"usePathname\");\n    // In the case where this is `null`, the compat types added in `next-env.d.ts`\n    // will add a new overload that changes the return type to include `null`.\n    return (0, _react.useContext)(_hooksclientcontextsharedruntime.PathnameContext);\n}\nfunction useRouter() {\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"useRouter\");\n    const router = (0, _react.useContext)(_approutercontextsharedruntime.AppRouterContext);\n    if (router === null) {\n        throw new Error(\"invariant expected app router to be mounted\");\n    }\n    return router;\n}\n// this function performs a depth-first search of the tree to find the selected\n// params\nfunction getSelectedParams(tree, params) {\n    if (params === void 0) params = {};\n    const parallelRoutes = tree[1];\n    for (const parallelRoute of Object.values(parallelRoutes)){\n        const segment = parallelRoute[0];\n        const isDynamicParameter = Array.isArray(segment);\n        const segmentValue = isDynamicParameter ? segment[1] : segment;\n        if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) continue;\n        // Ensure catchAll and optional catchall are turned into an array\n        const isCatchAll = isDynamicParameter && (segment[2] === \"c\" || segment[2] === \"oc\");\n        if (isCatchAll) {\n            params[segment[0]] = segment[1].split(\"/\");\n        } else if (isDynamicParameter) {\n            params[segment[0]] = segment[1];\n        }\n        params = getSelectedParams(parallelRoute, params);\n    }\n    return params;\n}\nfunction useParams() {\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"useParams\");\n    const globalLayoutRouter = (0, _react.useContext)(_approutercontextsharedruntime.GlobalLayoutRouterContext);\n    const pathParams = (0, _react.useContext)(_hooksclientcontextsharedruntime.PathParamsContext);\n    return (0, _react.useMemo)(()=>{\n        // When it's under app router\n        if (globalLayoutRouter == null ? void 0 : globalLayoutRouter.tree) {\n            return getSelectedParams(globalLayoutRouter.tree);\n        }\n        // When it's under client side pages router\n        return pathParams;\n    }, [\n        globalLayoutRouter == null ? void 0 : globalLayoutRouter.tree,\n        pathParams\n    ]);\n}\n// TODO-APP: handle parallel routes\n/**\n * Get the canonical parameters from the current level to the leaf node.\n */ function getSelectedLayoutSegmentPath(tree, parallelRouteKey, first, segmentPath) {\n    if (first === void 0) first = true;\n    if (segmentPath === void 0) segmentPath = [];\n    let node;\n    if (first) {\n        // Use the provided parallel route key on the first parallel route\n        node = tree[1][parallelRouteKey];\n    } else {\n        // After first parallel route prefer children, if there's no children pick the first parallel route.\n        const parallelRoutes = tree[1];\n        var _parallelRoutes_children;\n        node = (_parallelRoutes_children = parallelRoutes.children) != null ? _parallelRoutes_children : Object.values(parallelRoutes)[0];\n    }\n    if (!node) return segmentPath;\n    const segment = node[0];\n    const segmentValue = (0, _getsegmentvalue.getSegmentValue)(segment);\n    if (!segmentValue || segmentValue.startsWith(_segment.PAGE_SEGMENT_KEY)) {\n        return segmentPath;\n    }\n    segmentPath.push(segmentValue);\n    return getSelectedLayoutSegmentPath(node, parallelRouteKey, false, segmentPath);\n}\nfunction useSelectedLayoutSegments(parallelRouteKey) {\n    if (parallelRouteKey === void 0) parallelRouteKey = \"children\";\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"useSelectedLayoutSegments\");\n    const { tree } = (0, _react.useContext)(_approutercontextsharedruntime.LayoutRouterContext);\n    return getSelectedLayoutSegmentPath(tree, parallelRouteKey);\n}\nfunction useSelectedLayoutSegment(parallelRouteKey) {\n    _s();\n    if (parallelRouteKey === void 0) parallelRouteKey = \"children\";\n    (0, _clienthookinservercomponenterror.clientHookInServerComponentError)(\"useSelectedLayoutSegment\");\n    const selectedLayoutSegments = useSelectedLayoutSegments(parallelRouteKey);\n    if (selectedLayoutSegments.length === 0) {\n        return null;\n    }\n    return selectedLayoutSegments[0];\n}\n_s(useSelectedLayoutSegment, \"rc1U92JxkDTv7MNGlutCvlwOCmc=\", false, function() {\n    return [\n        useSelectedLayoutSegments\n    ];\n});\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=navigation.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbi5qcyIsIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0FBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBY047QUFDQSxTQUFTYyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJcEIsT0FBT0MsY0FBYyxDQUFDa0IsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRaEIsU0FBUztJQUNiRyx5QkFBeUI7UUFDckIsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLGFBQWE7UUFDVCxPQUFPQTtJQUNYO0lBQ0FDLDJCQUEyQjtRQUN2QixPQUFPZ0IsaUNBQWlDaEIseUJBQXlCO0lBQ3JFO0lBQ0FDLHVCQUF1QjtRQUNuQixPQUFPZSxpQ0FBaUNmLHFCQUFxQjtJQUNqRTtJQUNBQyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtJQUNBQyxXQUFXO1FBQ1AsT0FBT0E7SUFDWDtJQUNBQywyQkFBMkI7UUFDdkIsT0FBT0E7SUFDWDtJQUNBQywwQkFBMEI7UUFDdEIsT0FBT0E7SUFDWDtJQUNBQyxVQUFVO1FBQ04sT0FBT1csVUFBVVgsUUFBUTtJQUM3QjtJQUNBQyxtQkFBbUI7UUFDZixPQUFPVSxVQUFVVixpQkFBaUI7SUFDdEM7SUFDQUMsY0FBYztRQUNWLE9BQU9TLFVBQVVULFlBQVk7SUFDakM7SUFDQUMsVUFBVTtRQUNOLE9BQU9TLFVBQVVULFFBQVE7SUFDN0I7QUFDSjtBQUNBLE1BQU1VLFNBQVNDLG1CQUFPQSxDQUFDLG1GQUFPO0FBQzlCLE1BQU1DLGlDQUFpQ0QsbUJBQU9BLENBQUMsd0pBQW9EO0FBQ25HLE1BQU1FLG1DQUFtQ0YsbUJBQU9B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QixnQ0FBZ0MsRUFBRTtJQUN4RSxNQUFNLEVBQUVXLElBQUksRUFBRSxHQUFHLENBQUMsR0FBR3RDLE9BQU82QixVQUFVLEVBQUUzQiwrQkFBK0I4RCxtQkFBbUI7SUFDMUYsT0FBT1QsNkJBQTZCakIsTUFBTWtCO0FBQzlDO0FBQ0EsU0FBU3RFLHlCQUF5QnNFLGdCQUFnQjs7SUFDOUMsSUFBSUEscUJBQXFCLEtBQUssR0FBR0EsbUJBQW1CO0lBQ25ELElBQUdwRCxrQ0FBa0N1QixnQ0FBZ0MsRUFBRTtJQUN4RSxNQUFNc0MseUJBQXlCaEYsMEJBQTBCdUU7SUFDekQsSUFBSVMsdUJBQXVCQyxNQUFNLEtBQUssR0FBRztRQUNyQyxPQUFPO0lBQ1g7SUFDQSxPQUFPRCxzQkFBc0IsQ0FBQyxFQUFFO0FBQ3BDO0dBUlMvRTs7UUFHMEJEOzs7QUFPbkMsSUFBSSxDQUFDLE9BQU9WLFFBQVE0RixPQUFPLEtBQUssY0FBZSxPQUFPNUYsUUFBUTRGLE9BQU8sS0FBSyxZQUFZNUYsUUFBUTRGLE9BQU8sS0FBSyxJQUFJLEtBQU0sT0FBTzVGLFFBQVE0RixPQUFPLENBQUNDLFVBQVUsS0FBSyxhQUFhO0lBQ3JLL0YsT0FBT0MsY0FBYyxDQUFDQyxRQUFRNEYsT0FBTyxFQUFFLGNBQWM7UUFBRTNGLE9BQU87SUFBSztJQUNuRUgsT0FBT2dHLE1BQU0sQ0FBQzlGLFFBQVE0RixPQUFPLEVBQUU1RjtJQUMvQkUsT0FBT0YsT0FBTyxHQUFHQSxRQUFRNEYsT0FBTztBQUNsQyxFQUVBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb24uanM/MzQ4MiJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbjAgJiYgKG1vZHVsZS5leHBvcnRzID0ge1xuICAgIFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zOiBudWxsLFxuICAgIHVzZVNlYXJjaFBhcmFtczogbnVsbCxcbiAgICB1c2VQYXRobmFtZTogbnVsbCxcbiAgICBTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0OiBudWxsLFxuICAgIHVzZVNlcnZlckluc2VydGVkSFRNTDogbnVsbCxcbiAgICB1c2VSb3V0ZXI6IG51bGwsXG4gICAgdXNlUGFyYW1zOiBudWxsLFxuICAgIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHM6IG51bGwsXG4gICAgdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50OiBudWxsLFxuICAgIHJlZGlyZWN0OiBudWxsLFxuICAgIHBlcm1hbmVudFJlZGlyZWN0OiBudWxsLFxuICAgIFJlZGlyZWN0VHlwZTogbnVsbCxcbiAgICBub3RGb3VuZDogbnVsbFxufSk7XG5mdW5jdGlvbiBfZXhwb3J0KHRhcmdldCwgYWxsKSB7XG4gICAgZm9yKHZhciBuYW1lIGluIGFsbClPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogYWxsW25hbWVdXG4gICAgfSk7XG59XG5fZXhwb3J0KGV4cG9ydHMsIHtcbiAgICBSZWFkb25seVVSTFNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSZWFkb25seVVSTFNlYXJjaFBhcmFtcztcbiAgICB9LFxuICAgIHVzZVNlYXJjaFBhcmFtczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VTZWFyY2hQYXJhbXM7XG4gICAgfSxcbiAgICB1c2VQYXRobmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VQYXRobmFtZTtcbiAgICB9LFxuICAgIFNlcnZlckluc2VydGVkSFRNTENvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3NlcnZlcmluc2VydGVkaHRtbHNoYXJlZHJ1bnRpbWUuU2VydmVySW5zZXJ0ZWRIVE1MQ29udGV4dDtcbiAgICB9LFxuICAgIHVzZVNlcnZlckluc2VydGVkSFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfc2VydmVyaW5zZXJ0ZWRodG1sc2hhcmVkcnVudGltZS51c2VTZXJ2ZXJJbnNlcnRlZEhUTUw7XG4gICAgfSxcbiAgICB1c2VSb3V0ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlUm91dGVyO1xuICAgIH0sXG4gICAgdXNlUGFyYW1zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZVBhcmFtcztcbiAgICB9LFxuICAgIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cztcbiAgICB9LFxuICAgIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB1c2VTZWxlY3RlZExheW91dFNlZ21lbnQ7XG4gICAgfSxcbiAgICByZWRpcmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVkaXJlY3QucmVkaXJlY3Q7XG4gICAgfSxcbiAgICBwZXJtYW5lbnRSZWRpcmVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfcmVkaXJlY3QucGVybWFuZW50UmVkaXJlY3Q7XG4gICAgfSxcbiAgICBSZWRpcmVjdFR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX3JlZGlyZWN0LlJlZGlyZWN0VHlwZTtcbiAgICB9LFxuICAgIG5vdEZvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9ub3Rmb3VuZC5ub3RGb3VuZDtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lID0gcmVxdWlyZShcIi4uLy4uL3NoYXJlZC9saWIvaG9va3MtY2xpZW50LWNvbnRleHQuc2hhcmVkLXJ1bnRpbWVcIik7XG5jb25zdCBfY2xpZW50aG9va2luc2VydmVyY29tcG9uZW50ZXJyb3IgPSByZXF1aXJlKFwiLi9jbGllbnQtaG9vay1pbi1zZXJ2ZXItY29tcG9uZW50LWVycm9yXCIpO1xuY29uc3QgX2dldHNlZ21lbnR2YWx1ZSA9IHJlcXVpcmUoXCIuL3JvdXRlci1yZWR1Y2VyL3JlZHVjZXJzL2dldC1zZWdtZW50LXZhbHVlXCIpO1xuY29uc3QgX3NlZ21lbnQgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9zZWdtZW50XCIpO1xuY29uc3QgX3NlcnZlcmluc2VydGVkaHRtbHNoYXJlZHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vLi4vc2hhcmVkL2xpYi9zZXJ2ZXItaW5zZXJ0ZWQtaHRtbC5zaGFyZWQtcnVudGltZVwiKTtcbmNvbnN0IF9yZWRpcmVjdCA9IHJlcXVpcmUoXCIuL3JlZGlyZWN0XCIpO1xuY29uc3QgX25vdGZvdW5kID0gcmVxdWlyZShcIi4vbm90LWZvdW5kXCIpO1xuY29uc3QgSU5URVJOQUxfVVJMU0VBUkNIUEFSQU1TX0lOU1RBTkNFID0gU3ltYm9sKFwiaW50ZXJuYWwgZm9yIHVybHNlYXJjaHBhcmFtcyByZWFkb25seVwiKTtcbmZ1bmN0aW9uIHJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihcIlJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIGNhbm5vdCBiZSBtb2RpZmllZFwiKTtcbn1cbmNsYXNzIFJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbSU5URVJOQUxfVVJMU0VBUkNIUEFSQU1TX0lOU1RBTkNFXVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIGFwcGVuZCgpIHtcbiAgICAgICAgdGhyb3cgcmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvcigpO1xuICAgIH1cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIHRocm93IHJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKTtcbiAgICB9XG4gICAgc2V0KCkge1xuICAgICAgICB0aHJvdyByZWFkb25seVVSTFNlYXJjaFBhcmFtc0Vycm9yKCk7XG4gICAgfVxuICAgIHNvcnQoKSB7XG4gICAgICAgIHRocm93IHJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zRXJyb3IoKTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IodXJsU2VhcmNoUGFyYW1zKXtcbiAgICAgICAgdGhpc1tJTlRFUk5BTF9VUkxTRUFSQ0hQQVJBTVNfSU5TVEFOQ0VdID0gdXJsU2VhcmNoUGFyYW1zO1xuICAgICAgICB0aGlzLmVudHJpZXMgPSB1cmxTZWFyY2hQYXJhbXMuZW50cmllcy5iaW5kKHVybFNlYXJjaFBhcmFtcyk7XG4gICAgICAgIHRoaXMuZm9yRWFjaCA9IHVybFNlYXJjaFBhcmFtcy5mb3JFYWNoLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy5nZXQgPSB1cmxTZWFyY2hQYXJhbXMuZ2V0LmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy5nZXRBbGwgPSB1cmxTZWFyY2hQYXJhbXMuZ2V0QWxsLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy5oYXMgPSB1cmxTZWFyY2hQYXJhbXMuaGFzLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy5rZXlzID0gdXJsU2VhcmNoUGFyYW1zLmtleXMuYmluZCh1cmxTZWFyY2hQYXJhbXMpO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHVybFNlYXJjaFBhcmFtcy52YWx1ZXMuYmluZCh1cmxTZWFyY2hQYXJhbXMpO1xuICAgICAgICB0aGlzLnRvU3RyaW5nID0gdXJsU2VhcmNoUGFyYW1zLnRvU3RyaW5nLmJpbmQodXJsU2VhcmNoUGFyYW1zKTtcbiAgICAgICAgdGhpcy5zaXplID0gdXJsU2VhcmNoUGFyYW1zLnNpemU7XG4gICAgfVxufVxuZnVuY3Rpb24gdXNlU2VhcmNoUGFyYW1zKCkge1xuICAgICgwLCBfY2xpZW50aG9va2luc2VydmVyY29tcG9uZW50ZXJyb3IuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpKFwidXNlU2VhcmNoUGFyYW1zXCIpO1xuICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2hvb2tzY2xpZW50Y29udGV4dHNoYXJlZHJ1bnRpbWUuU2VhcmNoUGFyYW1zQ29udGV4dCk7XG4gICAgLy8gSW4gdGhlIGNhc2Ugd2hlcmUgdGhpcyBpcyBgbnVsbGAsIHRoZSBjb21wYXQgdHlwZXMgYWRkZWQgaW5cbiAgICAvLyBgbmV4dC1lbnYuZC50c2Agd2lsbCBhZGQgYSBuZXcgb3ZlcmxvYWQgdGhhdCBjaGFuZ2VzIHRoZSByZXR1cm4gdHlwZSB0b1xuICAgIC8vIGluY2x1ZGUgYG51bGxgLlxuICAgIGNvbnN0IHJlYWRvbmx5U2VhcmNoUGFyYW1zID0gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICBpZiAoIXNlYXJjaFBhcmFtcykge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgcm91dGVyIGlzIG5vdCByZWFkeSBpbiBwYWdlcywgd2Ugd29uJ3QgaGF2ZSB0aGUgc2VhcmNoIHBhcmFtc1xuICAgICAgICAgICAgLy8gYXZhaWxhYmxlLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkb25seVVSTFNlYXJjaFBhcmFtcyhzZWFyY2hQYXJhbXMpO1xuICAgIH0sIFtcbiAgICAgICAgc2VhcmNoUGFyYW1zXG4gICAgXSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgLy8gQXN5bmNMb2NhbFN0b3JhZ2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiB0aGUgY2xpZW50IGJ1bmRsZS5cbiAgICAgICAgY29uc3QgeyBiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmcgfSA9IHJlcXVpcmUoXCIuL2JhaWxvdXQtdG8tY2xpZW50LXJlbmRlcmluZ1wiKTtcbiAgICAgICAgLy8gVE9ETy1BUFA6IGhhbmRsZSBkeW5hbWljID0gJ2ZvcmNlLXN0YXRpYycgaGVyZSBhbmQgb24gdGhlIGNsaWVudFxuICAgICAgICBiYWlsb3V0VG9DbGllbnRSZW5kZXJpbmcoXCJ1c2VTZWFyY2hQYXJhbXMoKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlYWRvbmx5U2VhcmNoUGFyYW1zO1xufVxuZnVuY3Rpb24gdXNlUGF0aG5hbWUoKSB7XG4gICAgKDAsIF9jbGllbnRob29raW5zZXJ2ZXJjb21wb25lbnRlcnJvci5jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcikoXCJ1c2VQYXRobmFtZVwiKTtcbiAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB0aGlzIGlzIGBudWxsYCwgdGhlIGNvbXBhdCB0eXBlcyBhZGRlZCBpbiBgbmV4dC1lbnYuZC50c2BcbiAgICAvLyB3aWxsIGFkZCBhIG5ldyBvdmVybG9hZCB0aGF0IGNoYW5nZXMgdGhlIHJldHVybiB0eXBlIHRvIGluY2x1ZGUgYG51bGxgLlxuICAgIHJldHVybiAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lLlBhdGhuYW1lQ29udGV4dCk7XG59XG5mdW5jdGlvbiB1c2VSb3V0ZXIoKSB7XG4gICAgKDAsIF9jbGllbnRob29raW5zZXJ2ZXJjb21wb25lbnRlcnJvci5jbGllbnRIb29rSW5TZXJ2ZXJDb21wb25lbnRFcnJvcikoXCJ1c2VSb3V0ZXJcIik7XG4gICAgY29uc3Qgcm91dGVyID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuQXBwUm91dGVyQ29udGV4dCk7XG4gICAgaWYgKHJvdXRlciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhcmlhbnQgZXhwZWN0ZWQgYXBwIHJvdXRlciB0byBiZSBtb3VudGVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcm91dGVyO1xufVxuLy8gdGhpcyBmdW5jdGlvbiBwZXJmb3JtcyBhIGRlcHRoLWZpcnN0IHNlYXJjaCBvZiB0aGUgdHJlZSB0byBmaW5kIHRoZSBzZWxlY3RlZFxuLy8gcGFyYW1zXG5mdW5jdGlvbiBnZXRTZWxlY3RlZFBhcmFtcyh0cmVlLCBwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHBhcmFtcyA9IHt9O1xuICAgIGNvbnN0IHBhcmFsbGVsUm91dGVzID0gdHJlZVsxXTtcbiAgICBmb3IgKGNvbnN0IHBhcmFsbGVsUm91dGUgb2YgT2JqZWN0LnZhbHVlcyhwYXJhbGxlbFJvdXRlcykpe1xuICAgICAgICBjb25zdCBzZWdtZW50ID0gcGFyYWxsZWxSb3V0ZVswXTtcbiAgICAgICAgY29uc3QgaXNEeW5hbWljUGFyYW1ldGVyID0gQXJyYXkuaXNBcnJheShzZWdtZW50KTtcbiAgICAgICAgY29uc3Qgc2VnbWVudFZhbHVlID0gaXNEeW5hbWljUGFyYW1ldGVyID8gc2VnbWVudFsxXSA6IHNlZ21lbnQ7XG4gICAgICAgIGlmICghc2VnbWVudFZhbHVlIHx8IHNlZ21lbnRWYWx1ZS5zdGFydHNXaXRoKF9zZWdtZW50LlBBR0VfU0VHTUVOVF9LRVkpKSBjb250aW51ZTtcbiAgICAgICAgLy8gRW5zdXJlIGNhdGNoQWxsIGFuZCBvcHRpb25hbCBjYXRjaGFsbCBhcmUgdHVybmVkIGludG8gYW4gYXJyYXlcbiAgICAgICAgY29uc3QgaXNDYXRjaEFsbCA9IGlzRHluYW1pY1BhcmFtZXRlciAmJiAoc2VnbWVudFsyXSA9PT0gXCJjXCIgfHwgc2VnbWVudFsyXSA9PT0gXCJvY1wiKTtcbiAgICAgICAgaWYgKGlzQ2F0Y2hBbGwpIHtcbiAgICAgICAgICAgIHBhcmFtc1tzZWdtZW50WzBdXSA9IHNlZ21lbnRbMV0uc3BsaXQoXCIvXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRHluYW1pY1BhcmFtZXRlcikge1xuICAgICAgICAgICAgcGFyYW1zW3NlZ21lbnRbMF1dID0gc2VnbWVudFsxXTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMgPSBnZXRTZWxlY3RlZFBhcmFtcyhwYXJhbGxlbFJvdXRlLCBwYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZnVuY3Rpb24gdXNlUGFyYW1zKCkge1xuICAgICgwLCBfY2xpZW50aG9va2luc2VydmVyY29tcG9uZW50ZXJyb3IuY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IpKFwidXNlUGFyYW1zXCIpO1xuICAgIGNvbnN0IGdsb2JhbExheW91dFJvdXRlciA9ICgwLCBfcmVhY3QudXNlQ29udGV4dCkoX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lLkdsb2JhbExheW91dFJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lLlBhdGhQYXJhbXNDb250ZXh0KTtcbiAgICByZXR1cm4gKDAsIF9yZWFjdC51c2VNZW1vKSgoKT0+e1xuICAgICAgICAvLyBXaGVuIGl0J3MgdW5kZXIgYXBwIHJvdXRlclxuICAgICAgICBpZiAoZ2xvYmFsTGF5b3V0Um91dGVyID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxMYXlvdXRSb3V0ZXIudHJlZSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFNlbGVjdGVkUGFyYW1zKGdsb2JhbExheW91dFJvdXRlci50cmVlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIGl0J3MgdW5kZXIgY2xpZW50IHNpZGUgcGFnZXMgcm91dGVyXG4gICAgICAgIHJldHVybiBwYXRoUGFyYW1zO1xuICAgIH0sIFtcbiAgICAgICAgZ2xvYmFsTGF5b3V0Um91dGVyID09IG51bGwgPyB2b2lkIDAgOiBnbG9iYWxMYXlvdXRSb3V0ZXIudHJlZSxcbiAgICAgICAgcGF0aFBhcmFtc1xuICAgIF0pO1xufVxuLy8gVE9ETy1BUFA6IGhhbmRsZSBwYXJhbGxlbCByb3V0ZXNcbi8qKlxuICogR2V0IHRoZSBjYW5vbmljYWwgcGFyYW1ldGVycyBmcm9tIHRoZSBjdXJyZW50IGxldmVsIHRvIHRoZSBsZWFmIG5vZGUuXG4gKi8gZnVuY3Rpb24gZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aCh0cmVlLCBwYXJhbGxlbFJvdXRlS2V5LCBmaXJzdCwgc2VnbWVudFBhdGgpIHtcbiAgICBpZiAoZmlyc3QgPT09IHZvaWQgMCkgZmlyc3QgPSB0cnVlO1xuICAgIGlmIChzZWdtZW50UGF0aCA9PT0gdm9pZCAwKSBzZWdtZW50UGF0aCA9IFtdO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgICAvLyBVc2UgdGhlIHByb3ZpZGVkIHBhcmFsbGVsIHJvdXRlIGtleSBvbiB0aGUgZmlyc3QgcGFyYWxsZWwgcm91dGVcbiAgICAgICAgbm9kZSA9IHRyZWVbMV1bcGFyYWxsZWxSb3V0ZUtleV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWZ0ZXIgZmlyc3QgcGFyYWxsZWwgcm91dGUgcHJlZmVyIGNoaWxkcmVuLCBpZiB0aGVyZSdzIG5vIGNoaWxkcmVuIHBpY2sgdGhlIGZpcnN0IHBhcmFsbGVsIHJvdXRlLlxuICAgICAgICBjb25zdCBwYXJhbGxlbFJvdXRlcyA9IHRyZWVbMV07XG4gICAgICAgIHZhciBfcGFyYWxsZWxSb3V0ZXNfY2hpbGRyZW47XG4gICAgICAgIG5vZGUgPSAoX3BhcmFsbGVsUm91dGVzX2NoaWxkcmVuID0gcGFyYWxsZWxSb3V0ZXMuY2hpbGRyZW4pICE9IG51bGwgPyBfcGFyYWxsZWxSb3V0ZXNfY2hpbGRyZW4gOiBPYmplY3QudmFsdWVzKHBhcmFsbGVsUm91dGVzKVswXTtcbiAgICB9XG4gICAgaWYgKCFub2RlKSByZXR1cm4gc2VnbWVudFBhdGg7XG4gICAgY29uc3Qgc2VnbWVudCA9IG5vZGVbMF07XG4gICAgY29uc3Qgc2VnbWVudFZhbHVlID0gKDAsIF9nZXRzZWdtZW50dmFsdWUuZ2V0U2VnbWVudFZhbHVlKShzZWdtZW50KTtcbiAgICBpZiAoIXNlZ21lbnRWYWx1ZSB8fCBzZWdtZW50VmFsdWUuc3RhcnRzV2l0aChfc2VnbWVudC5QQUdFX1NFR01FTlRfS0VZKSkge1xuICAgICAgICByZXR1cm4gc2VnbWVudFBhdGg7XG4gICAgfVxuICAgIHNlZ21lbnRQYXRoLnB1c2goc2VnbWVudFZhbHVlKTtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aChub2RlLCBwYXJhbGxlbFJvdXRlS2V5LCBmYWxzZSwgc2VnbWVudFBhdGgpO1xufVxuZnVuY3Rpb24gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyhwYXJhbGxlbFJvdXRlS2V5KSB7XG4gICAgaWYgKHBhcmFsbGVsUm91dGVLZXkgPT09IHZvaWQgMCkgcGFyYWxsZWxSb3V0ZUtleSA9IFwiY2hpbGRyZW5cIjtcbiAgICAoMCwgX2NsaWVudGhvb2tpbnNlcnZlcmNvbXBvbmVudGVycm9yLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKShcInVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudHNcIik7XG4gICAgY29uc3QgeyB0cmVlIH0gPSAoMCwgX3JlYWN0LnVzZUNvbnRleHQpKF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZS5MYXlvdXRSb3V0ZXJDb250ZXh0KTtcbiAgICByZXR1cm4gZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aCh0cmVlLCBwYXJhbGxlbFJvdXRlS2V5KTtcbn1cbmZ1bmN0aW9uIHVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudChwYXJhbGxlbFJvdXRlS2V5KSB7XG4gICAgaWYgKHBhcmFsbGVsUm91dGVLZXkgPT09IHZvaWQgMCkgcGFyYWxsZWxSb3V0ZUtleSA9IFwiY2hpbGRyZW5cIjtcbiAgICAoMCwgX2NsaWVudGhvb2tpbnNlcnZlcmNvbXBvbmVudGVycm9yLmNsaWVudEhvb2tJblNlcnZlckNvbXBvbmVudEVycm9yKShcInVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudFwiKTtcbiAgICBjb25zdCBzZWxlY3RlZExheW91dFNlZ21lbnRzID0gdXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyhwYXJhbGxlbFJvdXRlS2V5KTtcbiAgICBpZiAoc2VsZWN0ZWRMYXlvdXRTZWdtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RlZExheW91dFNlZ21lbnRzWzBdO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYXZpZ2F0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIlJlYWRvbmx5VVJMU2VhcmNoUGFyYW1zIiwidXNlU2VhcmNoUGFyYW1zIiwidXNlUGF0aG5hbWUiLCJTZXJ2ZXJJbnNlcnRlZEhUTUxDb250ZXh0IiwidXNlU2VydmVySW5zZXJ0ZWRIVE1MIiwidXNlUm91dGVyIiwidXNlUGFyYW1zIiwidXNlU2VsZWN0ZWRMYXlvdXRTZWdtZW50cyIsInVzZVNlbGVjdGVkTGF5b3V0U2VnbWVudCIsInJlZGlyZWN0IiwicGVybWFuZW50UmVkaXJlY3QiLCJSZWRpcmVjdFR5cGUiLCJub3RGb3VuZCIsIl9leHBvcnQiLCJ0YXJnZXQiLCJhbGwiLCJuYW1lIiwiZW51bWVyYWJsZSIsImdldCIsIl9zZXJ2ZXJpbnNlcnRlZGh0bWxzaGFyZWRydW50aW1lIiwiX3JlZGlyZWN0IiwiX25vdGZvdW5kIiwiX3JlYWN0IiwicmVxdWlyZSIsIl9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSIsIl9ob29rc2NsaWVudGNvbnRleHRzaGFyZWRydW50aW1lIiwiX2NsaWVudGhvb2tpbnNlcnZlcmNvbXBvbmVudGVycm9yIiwiX2dldHNlZ21lbnR2YWx1ZSIsIl9zZWdtZW50IiwiSU5URVJOQUxfVVJMU0VBUkNIUEFSQU1TX0lOU1RBTkNFIiwiU3ltYm9sIiwicmVhZG9ubHlVUkxTZWFyY2hQYXJhbXNFcnJvciIsIkVycm9yIiwiaXRlcmF0b3IiLCJhcHBlbmQiLCJkZWxldGUiLCJzZXQiLCJzb3J0IiwiY29uc3RydWN0b3IiLCJ1cmxTZWFyY2hQYXJhbXMiLCJlbnRyaWVzIiwiYmluZCIsImZvckVhY2giLCJnZXRBbGwiLCJoYXMiLCJrZXlzIiwidmFsdWVzIiwidG9TdHJpbmciLCJzaXplIiwiY2xpZW50SG9va0luU2VydmVyQ29tcG9uZW50RXJyb3IiLCJzZWFyY2hQYXJhbXMiLCJ1c2VDb250ZXh0IiwiU2VhcmNoUGFyYW1zQ29udGV4dCIsInJlYWRvbmx5U2VhcmNoUGFyYW1zIiwidXNlTWVtbyIsImJhaWxvdXRUb0NsaWVudFJlbmRlcmluZyIsIlBhdGhuYW1lQ29udGV4dCIsInJvdXRlciIsIkFwcFJvdXRlckNvbnRleHQiLCJnZXRTZWxlY3RlZFBhcmFtcyIsInRyZWUiLCJwYXJhbXMiLCJwYXJhbGxlbFJvdXRlcyIsInBhcmFsbGVsUm91dGUiLCJzZWdtZW50IiwiaXNEeW5hbWljUGFyYW1ldGVyIiwiQXJyYXkiLCJpc0FycmF5Iiwic2VnbWVudFZhbHVlIiwic3RhcnRzV2l0aCIsIlBBR0VfU0VHTUVOVF9LRVkiLCJpc0NhdGNoQWxsIiwic3BsaXQiLCJnbG9iYWxMYXlvdXRSb3V0ZXIiLCJHbG9iYWxMYXlvdXRSb3V0ZXJDb250ZXh0IiwicGF0aFBhcmFtcyIsIlBhdGhQYXJhbXNDb250ZXh0IiwiZ2V0U2VsZWN0ZWRMYXlvdXRTZWdtZW50UGF0aCIsInBhcmFsbGVsUm91dGVLZXkiLCJmaXJzdCIsInNlZ21lbnRQYXRoIiwibm9kZSIsIl9wYXJhbGxlbFJvdXRlc19jaGlsZHJlbiIsImNoaWxkcmVuIiwiZ2V0U2VnbWVudFZhbHVlIiwicHVzaCIsIkxheW91dFJvdXRlckNvbnRleHQiLCJzZWxlY3RlZExheW91dFNlZ21lbnRzIiwibGVuZ3RoIiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js":
/*!************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/not-found-boundary.js ***!
  \************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"NotFoundBoundary\", ({\n    enumerable: true,\n    get: function() {\n        return NotFoundBoundary;\n    }\n}));\nconst _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nconst _jsxruntime = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-runtime.js\");\nconst _react = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"));\nconst _navigation = __webpack_require__(/*! ./navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\nconst _notfound = __webpack_require__(/*! ./not-found */ \"(app-pages-browser)/./node_modules/next/dist/client/components/not-found.js\");\nconst _warnonce = __webpack_require__(/*! ../../shared/lib/utils/warn-once */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/utils/warn-once.js\");\nconst _approutercontextsharedruntime = __webpack_require__(/*! ../../shared/lib/app-router-context.shared-runtime */ \"(app-pages-browser)/./node_modules/next/dist/shared/lib/app-router-context.shared-runtime.js\");\nclass NotFoundErrorBoundary extends _react.default.Component {\n    componentDidCatch() {\n        if ( true && // A missing children slot is the typical not-found case, so no need to warn\n        !this.props.missingSlots.has(\"children\")) {\n            let warningMessage = \"No default component was found for a parallel route rendered on this page. Falling back to nearest NotFound boundary.\\n\" + \"Learn more: https://nextjs.org/docs/app/building-your-application/routing/parallel-routes#defaultjs\\n\\n\";\n            if (this.props.missingSlots.size > 0) {\n                const formattedSlots = Array.from(this.props.missingSlots).sort((a, b)=>a.localeCompare(b)).map((slot)=>\"@\" + slot).join(\", \");\n                warningMessage += \"Missing slots: \" + formattedSlots;\n            }\n            (0, _warnonce.warnOnce)(warningMessage);\n        }\n    }\n    static getDerivedStateFromError(error) {\n        if ((0, _notfound.isNotFoundError)(error)) {\n            return {\n                notFoundTriggered: true\n            };\n        }\n        // Re-throw if error is not for 404\n        throw error;\n    }\n    static getDerivedStateFromProps(props, state) {\n        /**\n     * Handles reset of the error boundary when a navigation happens.\n     * Ensures the error boundary does not stay enabled when navigating to a new page.\n     * Approach of setState in render is safe as it checks the previous pathname and then overrides\n     * it as outlined in https://react.dev/reference/react/useState#storing-information-from-previous-renders\n     */ if (props.pathname !== state.previousPathname && state.notFoundTriggered) {\n            return {\n                notFoundTriggered: false,\n                previousPathname: props.pathname\n            };\n        }\n        return {\n            notFoundTriggered: state.notFoundTriggered,\n            previousPathname: props.pathname\n        };\n    }\n    render() {\n        if (this.state.notFoundTriggered) {\n            return /*#__PURE__*/ (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {\n                children: [\n                    /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"robots\",\n                        content: \"noindex\"\n                    }),\n                     true && /*#__PURE__*/ (0, _jsxruntime.jsx)(\"meta\", {\n                        name: \"next-error\",\n                        content: \"not-found\"\n                    }),\n                    this.props.notFoundStyles,\n                    this.props.notFound\n                ]\n            });\n        }\n        return this.props.children;\n    }\n    constructor(props){\n        super(props);\n        this.state = {\n            notFoundTriggered: !!props.asNotFound,\n            previousPathname: props.pathname\n        };\n    }\n}\nfunction NotFoundBoundary(param) {\n    let { notFound, notFoundStyles, asNotFound, children } = param;\n    const pathname = (0, _navigation.usePathname)();\n    const missingSlots = (0, _react.useContext)(_approutercontextsharedruntime.MissingSlotContext);\n    return notFound ? /*#__PURE__*/ (0, _jsxruntime.jsx)(NotFoundErrorBoundary, {\n        pathname: pathname,\n        notFound: notFound,\n        notFoundStyles: notFoundStyles,\n        asNotFound: asNotFound,\n        missingSlots: missingSlots,\n        children: children\n    }) : /*#__PURE__*/ (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {\n        children: children\n    });\n}\n_c = NotFoundBoundary;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=not-found-boundary.js.map\nvar _c;\n$RefreshReg$(_c, \"NotFoundBoundary\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kLWJvdW5kYXJ5LmpzIiwibWFwcGluZ3MiOiJxREFFYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsb0RBQW1EO0lBQy9DSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsNEJBQTRCQyxtQkFBT0EsQ0FBQyxrSUFBMEM7QUFDcEYsTUFBTUMsY0FBY0QsbUJBQU9BLENBQUMscUdBQW1CO0FBQy9DLE1BQU1FLFNBQVMsV0FBVyxHQUFHSCwwQkFBMEJJLENBQUMsQ0FBQ0gsbUJBQU9BLENBQUMsbUZBQU87QUFDeEUsTUFBTUksY0FBY0osbUJBQU9BLENBQUMsa0dBQWM7QUFDMUMsTUFBTUssWUFBWUwsbUJBQU9BLENBQUMsZ0dBQWE7QUFDdkMsTUFBTU0sWUFBWU4sbUJBQU9BLENBQUMsb0hBQWtDO0FBQzVELE1BQU1PLGlDQUFpQ1AsbUJBQU9BLENBQUMsd0pBQW9EO0FBQ25HLE1BQU1RLDhCQUE4Qk4sT0FBT08sT0FBTyxDQUFDQyxTQUFTO0lBQ3hEQyxvQkFBb0I7UUFDaEIsSUFBSUMsS0FBc0MsSUFBSSw0RUFBNEU7UUFDMUgsQ0FBQyxJQUFJLENBQUNDLEtBQUssQ0FBQ0MsWUFBWSxDQUFDQyxHQUFHLENBQUMsYUFBYTtZQUN0QyxJQUFJQyxpQkFBaUIsNEhBQTRIO1lBQ2pKLElBQUksSUFBSSxDQUFDSCxLQUFLLENBQUNDLFlBQVksQ0FBQ0csSUFBSSxHQUFHLEdBQUc7Z0JBQ2xDLE1BQU1DLGlCQUFpQkMsTUFBTUMsSUFBSSxDQUFDLElBQUksQ0FBQ1AsS0FBSyxDQUFDQyxZQUFZLEVBQUVPLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFJRCxFQUFFRSxhQUFhLENBQUNELElBQUlFLEdBQUcsQ0FBQyxDQUFDQyxPQUFPLE1BQU1BLE1B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cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kLWJvdW5kYXJ5LmpzPzMyYzkiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm90Rm91bmRCb3VuZGFyeVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gTm90Rm91bmRCb3VuZGFyeTtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfd2lsZGNhcmQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZFwiKTtcbmNvbnN0IF9qc3hydW50aW1lID0gcmVxdWlyZShcInJlYWN0L2pzeC1ydW50aW1lXCIpO1xuY29uc3QgX3JlYWN0ID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcInJlYWN0XCIpKTtcbmNvbnN0IF9uYXZpZ2F0aW9uID0gcmVxdWlyZShcIi4vbmF2aWdhdGlvblwiKTtcbmNvbnN0IF9ub3Rmb3VuZCA9IHJlcXVpcmUoXCIuL25vdC1mb3VuZFwiKTtcbmNvbnN0IF93YXJub25jZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL3V0aWxzL3dhcm4tb25jZVwiKTtcbmNvbnN0IF9hcHByb3V0ZXJjb250ZXh0c2hhcmVkcnVudGltZSA9IHJlcXVpcmUoXCIuLi8uLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dC5zaGFyZWQtcnVudGltZVwiKTtcbmNsYXNzIE5vdEZvdW5kRXJyb3JCb3VuZGFyeSBleHRlbmRzIF9yZWFjdC5kZWZhdWx0LkNvbXBvbmVudCB7XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiICYmIC8vIEEgbWlzc2luZyBjaGlsZHJlbiBzbG90IGlzIHRoZSB0eXBpY2FsIG5vdC1mb3VuZCBjYXNlLCBzbyBubyBuZWVkIHRvIHdhcm5cbiAgICAgICAgIXRoaXMucHJvcHMubWlzc2luZ1Nsb3RzLmhhcyhcImNoaWxkcmVuXCIpKSB7XG4gICAgICAgICAgICBsZXQgd2FybmluZ01lc3NhZ2UgPSBcIk5vIGRlZmF1bHQgY29tcG9uZW50IHdhcyBmb3VuZCBmb3IgYSBwYXJhbGxlbCByb3V0ZSByZW5kZXJlZCBvbiB0aGlzIHBhZ2UuIEZhbGxpbmcgYmFjayB0byBuZWFyZXN0IE5vdEZvdW5kIGJvdW5kYXJ5LlxcblwiICsgXCJMZWFybiBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9hcHAvYnVpbGRpbmcteW91ci1hcHBsaWNhdGlvbi9yb3V0aW5nL3BhcmFsbGVsLXJvdXRlcyNkZWZhdWx0anNcXG5cXG5cIjtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm1pc3NpbmdTbG90cy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZFNsb3RzID0gQXJyYXkuZnJvbSh0aGlzLnByb3BzLm1pc3NpbmdTbG90cykuc29ydCgoYSwgYik9PmEubG9jYWxlQ29tcGFyZShiKSkubWFwKChzbG90KT0+XCJAXCIgKyBzbG90KS5qb2luKFwiLCBcIik7XG4gICAgICAgICAgICAgICAgd2FybmluZ01lc3NhZ2UgKz0gXCJNaXNzaW5nIHNsb3RzOiBcIiArIGZvcm1hdHRlZFNsb3RzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKDAsIF93YXJub25jZS53YXJuT25jZSkod2FybmluZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgaWYgKCgwLCBfbm90Zm91bmQuaXNOb3RGb3VuZEVycm9yKShlcnJvcikpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbm90Rm91bmRUcmlnZ2VyZWQ6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmUtdGhyb3cgaWYgZXJyb3IgaXMgbm90IGZvciA0MDRcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMocHJvcHMsIHN0YXRlKSB7XG4gICAgICAgIC8qKlxuICAgICAqIEhhbmRsZXMgcmVzZXQgb2YgdGhlIGVycm9yIGJvdW5kYXJ5IHdoZW4gYSBuYXZpZ2F0aW9uIGhhcHBlbnMuXG4gICAgICogRW5zdXJlcyB0aGUgZXJyb3IgYm91bmRhcnkgZG9lcyBub3Qgc3RheSBlbmFibGVkIHdoZW4gbmF2aWdhdGluZyB0byBhIG5ldyBwYWdlLlxuICAgICAqIEFwcHJvYWNoIG9mIHNldFN0YXRlIGluIHJlbmRlciBpcyBzYWZlIGFzIGl0IGNoZWNrcyB0aGUgcHJldmlvdXMgcGF0aG5hbWUgYW5kIHRoZW4gb3ZlcnJpZGVzXG4gICAgICogaXQgYXMgb3V0bGluZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvcmVmZXJlbmNlL3JlYWN0L3VzZVN0YXRlI3N0b3JpbmctaW5mb3JtYXRpb24tZnJvbS1wcmV2aW91cy1yZW5kZXJzXG4gICAgICovIGlmIChwcm9wcy5wYXRobmFtZSAhPT0gc3RhdGUucHJldmlvdXNQYXRobmFtZSAmJiBzdGF0ZS5ub3RGb3VuZFRyaWdnZXJlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5vdEZvdW5kVHJpZ2dlcmVkOiBzdGF0ZS5ub3RGb3VuZFRyaWdnZXJlZCxcbiAgICAgICAgICAgIHByZXZpb3VzUGF0aG5hbWU6IHByb3BzLnBhdGhuYW1lXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbmRlcigpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubm90Rm91bmRUcmlnZ2VyZWQpIHtcbiAgICAgICAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3hzKShfanN4cnVudGltZS5GcmFnbWVudCwge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAgICAgIC8qI19fUFVSRV9fKi8gKDAsIF9qc3hydW50aW1lLmpzeCkoXCJtZXRhXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicm9ib3RzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIm5vaW5kZXhcIlxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIiAmJiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKFwibWV0YVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm5leHQtZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwibm90LWZvdW5kXCJcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubm90Rm91bmRTdHlsZXMsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMubm90Rm91bmRcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHJvcHMpe1xuICAgICAgICBzdXBlcihwcm9wcyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBub3RGb3VuZFRyaWdnZXJlZDogISFwcm9wcy5hc05vdEZvdW5kLFxuICAgICAgICAgICAgcHJldmlvdXNQYXRobmFtZTogcHJvcHMucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBOb3RGb3VuZEJvdW5kYXJ5KHBhcmFtKSB7XG4gICAgbGV0IHsgbm90Rm91bmQsIG5vdEZvdW5kU3R5bGVzLCBhc05vdEZvdW5kLCBjaGlsZHJlbiB9ID0gcGFyYW07XG4gICAgY29uc3QgcGF0aG5hbWUgPSAoMCwgX25hdmlnYXRpb24udXNlUGF0aG5hbWUpKCk7XG4gICAgY29uc3QgbWlzc2luZ1Nsb3RzID0gKDAsIF9yZWFjdC51c2VDb250ZXh0KShfYXBwcm91dGVyY29udGV4dHNoYXJlZHJ1bnRpbWUuTWlzc2luZ1Nsb3RDb250ZXh0KTtcbiAgICByZXR1cm4gbm90Rm91bmQgPyAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKE5vdEZvdW5kRXJyb3JCb3VuZGFyeSwge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgIG5vdEZvdW5kOiBub3RGb3VuZCxcbiAgICAgICAgbm90Rm91bmRTdHlsZXM6IG5vdEZvdW5kU3R5bGVzLFxuICAgICAgICBhc05vdEZvdW5kOiBhc05vdEZvdW5kLFxuICAgICAgICBtaXNzaW5nU2xvdHM6IG1pc3NpbmdTbG90cyxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuXG4gICAgfSkgOiAvKiNfX1BVUkVfXyovICgwLCBfanN4cnVudGltZS5qc3gpKF9qc3hydW50aW1lLkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlblxuICAgIH0pO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3QtZm91bmQtYm91bmRhcnkuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiZW51bWVyYWJsZSIsImdldCIsIk5vdEZvdW5kQm91bmRhcnkiLCJfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkIiwicmVxdWlyZSIsIl9qc3hydW50aW1lIiwiX3JlYWN0IiwiXyIsIl9uYXZpZ2F0aW9uIiwiX25vdGZvdW5kIiwiX3dhcm5vbmNlIiwiX2FwcHJvdXRlcmNvbnRleHRzaGFyZWRydW50aW1lIiwiTm90Rm91bmRFcnJvckJvdW5kYXJ5IiwiZGVmYXVsdCIsIkNvbXBvbmVudCIsImNvbXBvbmVudERpZENhdGNoIiwicHJvY2VzcyIsInByb3BzIiwibWlzc2luZ1Nsb3RzIiwiaGFzIiwid2FybmluZ01lc3NhZ2UiLCJzaXplIiwiZm9ybWF0dGVkU2xvdHMiLCJBcnJheSIsImZyb20iLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibWFwIiwic2xvdCIsImpvaW4iLCJ3YXJuT25jZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImVycm9yIiwiaXNOb3RGb3VuZEVycm9yIiwibm90Rm91bmRUcmlnZ2VyZWQiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJzdGF0ZSIsInBhdGhuYW1lIiwicHJldmlvdXNQYXRobmFtZSIsInJlbmRlciIsImpzeHMiLCJGcmFnbWVudCIsImNoaWxkcmVuIiwianN4IiwibmFtZSIsImNvbnRlbnQiLCJub3RGb3VuZFN0eWxlcyIsIm5vdEZvdW5kIiwiY29uc3RydWN0b3IiLCJhc05vdEZvdW5kIiwicGFyYW0iLCJ1c2VQYXRobmFtZSIsInVzZUNvbnRleHQiLCJNaXNzaW5nU2xvdENvbnRleHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found-boundary.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/not-found.js":
/*!***************************************************************!*\
  !*** ./node_modules/next/dist/client/components/not-found.js ***!
  \***************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    notFound: function() {\n        return notFound;\n    },\n    isNotFoundError: function() {\n        return isNotFoundError;\n    }\n});\nconst NOT_FOUND_ERROR_CODE = \"NEXT_NOT_FOUND\";\nfunction notFound() {\n    // eslint-disable-next-line no-throw-literal\n    const error = new Error(NOT_FOUND_ERROR_CODE);\n    error.digest = NOT_FOUND_ERROR_CODE;\n    throw error;\n}\nfunction isNotFoundError(error) {\n    if (typeof error !== \"object\" || error === null || !(\"digest\" in error)) {\n        return false;\n    }\n    return error.digest === NOT_FOUND_ERROR_CODE;\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=not-found.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvbm90LWZvdW5kLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBR047QUFDQSxTQUFTRyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJVCxPQUFPQyxjQUFjLENBQUNPLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUUwsU0FBUztJQUNiRyxVQUFVO1FBQ04sT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTyx1QkFBdUI7QUFDN0IsU0FBU1I7SUFDTCw0Q0FBNEM7SUFDNUMsTUFBTVMsUUFBUSxJQUFJQyxNQUFNRjtJQUN4QkMsTUFBTUUsTUFBTSxHQUFHSDtJQUNmLE1BQU1DO0FBQ1Y7QUFDQSxTQUFTUixnQkFBZ0JRLEtBQUs7SUFDMUIsSUFBSSxPQUFPQSxVQUFVLFlBQVlBLFVBQVUsUUFBUSxDQUFFLGFBQVlBLEtBQUksR0FBSTtRQUNyRSxPQUFPO0lBQ1g7SUFDQSxPQUFPQSxNQUFNRSxNQUFNLEtBQUtIO0FBQzVCO0FBRUEsSUFBSSxDQUFDLE9BQU9YLFFBQVFlLE9BQU8sS0FBSyxjQUFlLE9BQU9mLFFBQVFlLE9BQU8sS0FBSyxZQUFZZixRQUFRZSxPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9mLFFBQVFlLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcktsQixPQUFPQyxjQUFjLENBQUNDLFFBQVFlLE9BQU8sRUFBRSxjQUFjO1FBQUVkLE9BQU87SUFBSztJQUNuRUgsT0FBT21CLE1BQU0sQ0FBQ2pCLFFBQVFlLE9BQU8sRUFBRWY7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUWUsT0FBTztBQUNsQyxFQUVBLHFDQUFxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL25vdC1mb3VuZC5qcz80MjAzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgbm90Rm91bmQ6IG51bGwsXG4gICAgaXNOb3RGb3VuZEVycm9yOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIG5vdEZvdW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5vdEZvdW5kO1xuICAgIH0sXG4gICAgaXNOb3RGb3VuZEVycm9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGlzTm90Rm91bmRFcnJvcjtcbiAgICB9XG59KTtcbmNvbnN0IE5PVF9GT1VORF9FUlJPUl9DT0RFID0gXCJORVhUX05PVF9GT1VORFwiO1xuZnVuY3Rpb24gbm90Rm91bmQoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXRocm93LWxpdGVyYWxcbiAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihOT1RfRk9VTkRfRVJST1JfQ09ERSk7XG4gICAgZXJyb3IuZGlnZXN0ID0gTk9UX0ZPVU5EX0VSUk9SX0NPREU7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5mdW5jdGlvbiBpc05vdEZvdW5kRXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodHlwZW9mIGVycm9yICE9PSBcIm9iamVjdFwiIHx8IGVycm9yID09PSBudWxsIHx8ICEoXCJkaWdlc3RcIiBpbiBlcnJvcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZXJyb3IuZGlnZXN0ID09PSBOT1RfRk9VTkRfRVJST1JfQ09ERTtcbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm90LWZvdW5kLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIm1vZHVsZSIsIm5vdEZvdW5kIiwiaXNOb3RGb3VuZEVycm9yIiwiX2V4cG9ydCIsInRhcmdldCIsImFsbCIsIm5hbWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiTk9UX0ZPVU5EX0VSUk9SX0NPREUiLCJlcnJvciIsIkVycm9yIiwiZGlnZXN0IiwiZGVmYXVsdCIsIl9fZXNNb2R1bGUiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/not-found.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/client/components/promise-queue.js":
/*!*******************************************************************!*\
  !*** ./node_modules/next/dist/client/components/promise-queue.js ***!
  \*******************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n    This is a simple promise queue that allows you to limit the number of concurrent promises\n    that are running at any given time. It's used to limit the number of concurrent\n    prefetch requests that are being made to the server but could be used for other\n    things as well.\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"PromiseQueue\", ({\n    enumerable: true,\n    get: function() {\n        return PromiseQueue;\n    }\n}));\nconst _class_private_field_loose_base = __webpack_require__(/*! @swc/helpers/_/_class_private_field_loose_base */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_loose_base.js\");\nconst _class_private_field_loose_key = __webpack_require__(/*! @swc/helpers/_/_class_private_field_loose_key */ \"(app-pages-browser)/./node_modules/@swc/helpers/esm/_class_private_field_loose_key.js\");\nvar _maxConcurrency = /*#__PURE__*/ _class_private_field_loose_key._(\"_maxConcurrency\"), _runningCount = /*#__PURE__*/ _class_private_field_loose_key._(\"_runningCount\"), _queue = /*#__PURE__*/ _class_private_field_loose_key._(\"_queue\"), _processNext = /*#__PURE__*/ _class_private_field_loose_key._(\"_processNext\");\nclass PromiseQueue {\n    enqueue(promiseFn) {\n        let taskResolve;\n        let taskReject;\n        const taskPromise = new Promise((resolve, reject)=>{\n            taskResolve = resolve;\n            taskReject = reject;\n        });\n        const task = async ()=>{\n            try {\n                _class_private_field_loose_base._(this, _runningCount)[_runningCount]++;\n                const result = await promiseFn();\n                taskResolve(result);\n            } catch (error) {\n                taskReject(error);\n            } finally{\n                _class_private_field_loose_base._(this, _runningCount)[_runningCount]--;\n                _class_private_field_loose_base._(this, _processNext)[_processNext]();\n            }\n        };\n        const enqueueResult = {\n            promiseFn: taskPromise,\n            task\n        };\n        // wonder if we should take a LIFO approach here\n        _class_private_field_loose_base._(this, _queue)[_queue].push(enqueueResult);\n        _class_private_field_loose_base._(this, _processNext)[_processNext]();\n        return taskPromise;\n    }\n    bump(promiseFn) {\n        const index = _class_private_field_loose_base._(this, _queue)[_queue].findIndex((item)=>item.promiseFn === promiseFn);\n        if (index > -1) {\n            const bumpedItem = _class_private_field_loose_base._(this, _queue)[_queue].splice(index, 1)[0];\n            _class_private_field_loose_base._(this, _queue)[_queue].unshift(bumpedItem);\n            _class_private_field_loose_base._(this, _processNext)[_processNext](true);\n        }\n    }\n    constructor(maxConcurrency = 5){\n        Object.defineProperty(this, _processNext, {\n            value: processNext\n        });\n        Object.defineProperty(this, _maxConcurrency, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _runningCount, {\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, _queue, {\n            writable: true,\n            value: void 0\n        });\n        _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] = maxConcurrency;\n        _class_private_field_loose_base._(this, _runningCount)[_runningCount] = 0;\n        _class_private_field_loose_base._(this, _queue)[_queue] = [];\n    }\n}\nfunction processNext(forced) {\n    if (forced === void 0) forced = false;\n    if ((_class_private_field_loose_base._(this, _runningCount)[_runningCount] < _class_private_field_loose_base._(this, _maxConcurrency)[_maxConcurrency] || forced) && _class_private_field_loose_base._(this, _queue)[_queue].length > 0) {\n        var _class_private_field_loose_base__queue_shift;\n        (_class_private_field_loose_base__queue_shift = _class_private_field_loose_base._(this, _queue)[_queue].shift()) == null ? void 0 : _class_private_field_loose_base__queue_shift.task();\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=promise-queue.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY2xpZW50L2NvbXBvbmVudHMvcHJvbWlzZS1xdWV1ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7QUFLQSxHQUFnQjtBQUNoQkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILGdEQUErQztJQUMzQ0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLGtDQUFrQ0MsbUJBQU9BLENBQUMsOElBQWdEO0FBQ2hHLE1BQU1DLGlDQUFpQ0QsbUJBQU9BLENBQUMsNElBQStDO0FBQzlGLElBQUlFLGtCQUFrQixXQUFXLEdBQUdELCtCQUErQkUsQ0FBQyxDQUFDLG9CQUFvQkMsZ0JBQWdCLFdBQVcsR0FBR0gsK0JBQStCRSxDQUFDLENBQUMsa0JBQWtCRSxTQUFTLFdBQVcsR0FBR0osK0JBQStCRSxDQUFDLENBQUMsV0FBV0csZUFBZSxXQUFXLEdBQUdMLCtCQUErQkUsQ0FBQyxDQUFDO0FBQzNTLE1BQU1MO0lBQ0ZTLFFBQVFDLFNBQVMsRUFBRTtRQUNmLElBQUlDO1FBQ0osSUFBSUM7UUFDSixNQUFNQyxjQUFjLElBQUlDLFFBQVEsQ0FBQ0MsU0FBU0M7WUFDdENMLGNBQWNJO1lBQ2RILGFBQWFJO1FBQ2pCO1FBQ0EsTUFBTUMsT0FBTztZQUNULElBQUk7Z0JBQ0FoQixnQ0FBZ0NJLENBQUMsQ0FBQyxJQUFJLEVBQUVDLGNBQWMsQ0FBQ0EsY0FBYztnQkFDckUsTUFBTVksU0FBUyxNQUFNUjtnQkFDckJDLFlBQVlPO1lBQ2hCLEVBQUUsT0FBT0MsT0FBTztnQkFDWlAsV0FBV087WUFDZixTQUFTO2dCQUNMbEIsZ0NBQWdDSSxDQUFDLENBQUMsSUFBSSxFQUFFQyxjQUFjLENBQUNBLGNBQWM7Z0JBQ3JFTCxnQ0FBZ0NJLENBQUMsQ0FBQyxJQUFJLEVBQUVHLGFBQWEsQ0FBQ0EsYUFBYTtZQUN2RTtRQUNKO1FB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Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9wcm9taXNlLXF1ZXVlLmpzPzgxNjciXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgICBUaGlzIGlzIGEgc2ltcGxlIHByb21pc2UgcXVldWUgdGhhdCBhbGxvd3MgeW91IHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgY29uY3VycmVudCBwcm9taXNlc1xuICAgIHRoYXQgYXJlIHJ1bm5pbmcgYXQgYW55IGdpdmVuIHRpbWUuIEl0J3MgdXNlZCB0byBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICBwcmVmZXRjaCByZXF1ZXN0cyB0aGF0IGFyZSBiZWluZyBtYWRlIHRvIHRoZSBzZXJ2ZXIgYnV0IGNvdWxkIGJlIHVzZWQgZm9yIG90aGVyXG4gICAgdGhpbmdzIGFzIHdlbGwuXG4qLyBcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VRdWV1ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZVF1ZXVlO1xuICAgIH1cbn0pO1xuY29uc3QgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZSA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9fY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlXCIpO1xuY29uc3QgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2Vfa2V5ID0gcmVxdWlyZShcIkBzd2MvaGVscGVycy9fL19jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2tleVwiKTtcbnZhciBfbWF4Q29uY3VycmVuY3kgPSAvKiNfX1BVUkVfXyovIF9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2tleS5fKFwiX21heENvbmN1cnJlbmN5XCIpLCBfcnVubmluZ0NvdW50ID0gLyojX19QVVJFX18qLyBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9rZXkuXyhcIl9ydW5uaW5nQ291bnRcIiksIF9xdWV1ZSA9IC8qI19fUFVSRV9fKi8gX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2Vfa2V5Ll8oXCJfcXVldWVcIiksIF9wcm9jZXNzTmV4dCA9IC8qI19fUFVSRV9fKi8gX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2Vfa2V5Ll8oXCJfcHJvY2Vzc05leHRcIik7XG5jbGFzcyBQcm9taXNlUXVldWUge1xuICAgIGVucXVldWUocHJvbWlzZUZuKSB7XG4gICAgICAgIGxldCB0YXNrUmVzb2x2ZTtcbiAgICAgICAgbGV0IHRhc2tSZWplY3Q7XG4gICAgICAgIGNvbnN0IHRhc2tQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCk9PntcbiAgICAgICAgICAgIHRhc2tSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRhc2tSZWplY3QgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0YXNrID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9ydW5uaW5nQ291bnQpW19ydW5uaW5nQ291bnRdKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcHJvbWlzZUZuKCk7XG4gICAgICAgICAgICAgICAgdGFza1Jlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGFza1JlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9IGZpbmFsbHl7XG4gICAgICAgICAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9ydW5uaW5nQ291bnQpW19ydW5uaW5nQ291bnRdLS07XG4gICAgICAgICAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9wcm9jZXNzTmV4dClbX3Byb2Nlc3NOZXh0XSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlbnF1ZXVlUmVzdWx0ID0ge1xuICAgICAgICAgICAgcHJvbWlzZUZuOiB0YXNrUHJvbWlzZSxcbiAgICAgICAgICAgIHRhc2tcbiAgICAgICAgfTtcbiAgICAgICAgLy8gd29uZGVyIGlmIHdlIHNob3VsZCB0YWtlIGEgTElGTyBhcHByb2FjaCBoZXJlXG4gICAgICAgIF9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2Jhc2UuXyh0aGlzLCBfcXVldWUpW19xdWV1ZV0ucHVzaChlbnF1ZXVlUmVzdWx0KTtcbiAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9wcm9jZXNzTmV4dClbX3Byb2Nlc3NOZXh0XSgpO1xuICAgICAgICByZXR1cm4gdGFza1Byb21pc2U7XG4gICAgfVxuICAgIGJ1bXAocHJvbWlzZUZuKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9xdWV1ZSlbX3F1ZXVlXS5maW5kSW5kZXgoKGl0ZW0pPT5pdGVtLnByb21pc2VGbiA9PT0gcHJvbWlzZUZuKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIGNvbnN0IGJ1bXBlZEl0ZW0gPSBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlLl8odGhpcywgX3F1ZXVlKVtfcXVldWVdLnNwbGljZShpbmRleCwgMSlbMF07XG4gICAgICAgICAgICBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlLl8odGhpcywgX3F1ZXVlKVtfcXVldWVdLnVuc2hpZnQoYnVtcGVkSXRlbSk7XG4gICAgICAgICAgICBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlLl8odGhpcywgX3Byb2Nlc3NOZXh0KVtfcHJvY2Vzc05leHRdKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1heENvbmN1cnJlbmN5ID0gNSl7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBfcHJvY2Vzc05leHQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBwcm9jZXNzTmV4dFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIF9tYXhDb25jdXJyZW5jeSwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3J1bm5pbmdDb3VudCwge1xuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX3F1ZXVlLCB7XG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgICAgIF9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2Jhc2UuXyh0aGlzLCBfbWF4Q29uY3VycmVuY3kpW19tYXhDb25jdXJyZW5jeV0gPSBtYXhDb25jdXJyZW5jeTtcbiAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9ydW5uaW5nQ291bnQpW19ydW5uaW5nQ291bnRdID0gMDtcbiAgICAgICAgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9xdWV1ZSlbX3F1ZXVlXSA9IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NOZXh0KGZvcmNlZCkge1xuICAgIGlmIChmb3JjZWQgPT09IHZvaWQgMCkgZm9yY2VkID0gZmFsc2U7XG4gICAgaWYgKChfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlLl8odGhpcywgX3J1bm5pbmdDb3VudClbX3J1bm5pbmdDb3VudF0gPCBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlLl8odGhpcywgX21heENvbmN1cnJlbmN5KVtfbWF4Q29uY3VycmVuY3ldIHx8IGZvcmNlZCkgJiYgX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9xdWV1ZSlbX3F1ZXVlXS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9iYXNlX19xdWV1ZV9zaGlmdDtcbiAgICAgICAgKF9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2Jhc2VfX3F1ZXVlX3NoaWZ0ID0gX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZS5fKHRoaXMsIF9xdWV1ZSlbX3F1ZXVlXS5zaGlmdCgpKSA9PSBudWxsID8gdm9pZCAwIDogX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZV9fcXVldWVfc2hpZnQudGFzaygpO1xuICAgIH1cbn1cblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS1xdWV1ZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiUHJvbWlzZVF1ZXVlIiwiX2NsYXNzX3ByaXZhdGVfZmllbGRfbG9vc2VfYmFzZSIsInJlcXVpcmUiLCJfY2xhc3NfcHJpdmF0ZV9maWVsZF9sb29zZV9rZXkiLCJfbWF4Q29uY3VycmVuY3kiLCJfIiwiX3J1bm5pbmdDb3VudCIsIl9xdWV1ZSIsIl9wcm9jZXNzTmV4dCIsImVucXVldWUiLCJwcm9taXNlRm4iLCJ0YXNrUmVzb2x2ZSIsInRhc2tSZWplY3QiLCJ0YXNrUHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwidGFzayIsInJlc3VsdCIsImVycm9yIiwiZW5xdWV1ZVJlc3VsdCIsInB1c2giLCJidW1wIiwiaW5kZXgiLCJmaW5kSW5kZXgiLCJpdGVtIiwiYnVtcGVkSXRlbSIsInNwbGljZSIsInVuc2hpZnQiLCJjb25zdHJ1Y3RvciIsIm1heENvbmN1cnJlbmN5IiwicHJvY2Vzc05leHQiLCJ3cml0YWJsZSIsImZvcmNlZCIsImxlbmd0aCIsIl9jbGFzc19wcml2YXRlX2ZpZWxkX2xvb3NlX2Jhc2VfX3F1ZXVlX3NoaWZ0Iiwic2hpZnQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/client/components/promise-queue.js\n"));

/***/ })

}]);